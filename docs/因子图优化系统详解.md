# MonoLaneMapping 因子图优化系统详解

本文档整理了项目核心技术的深入分析，帮助理解基于因子图的车道地图构建系统。

---

## 目录

1. [因子图优化核心概念](#1-因子图优化核心概念)
2. [因子定义与数学原理](#2-因子定义与数学原理)
3. [优化系统构建流程](#3-优化系统构建流程)
4. [数据流与信息使用](#4-数据流与信息使用)
5. [EKF与因子图对比](#5-ekf与因子图对比)
6. [高级主题与实现细节](#6-高级主题与实现细节)

---

## 1. 因子图优化核心概念

### 1.1 输入输出概览

**系统输入**：
```
感知模块（PersFormer等）
├─ lanes: 车道点云列表
│   ├─ xyz: N×3 的3D点坐标（相机坐标系）
│   ├─ track_id: 车道跟踪ID
│   ├─ category: 车道类型
│   └─ visibility: 可见性
│
└─ 里程计
    ├─ T_wc: 世界到相机的变换矩阵 4×4
    └─ timestamp: 时间戳
```

**系统输出**：
```
优化后的车道地图
└─ lanes_in_map: {lane_id → LaneFeature}
    ├─ ctrl_pts: LinkedPoints（优化后的控制点链表）
    ├─ points: 平滑后的车道点云
    └─ id: 车道全局ID
```

### 1.2 核心数据结构

```python
# 控制点节点
class Node:
    item: np.ndarray      # 控制点3D坐标 [x, y, z]
    id: int               # 节点局部ID
    gtsam_key: Symbol     # GTSAM优化变量符号 L(idx)
    lane_id: int          # 所属车道ID

# 控制点链表（每条车道）
class LinkedPoints:
    items: List[Node]     # 控制点链表
    kdtree: KDTree        # 用于最近邻搜索
    max_node_id: int      # 最大节点ID

# 车道特征
class LaneFeature:
    id: int               # 车道ID（-1表示未关联）
    points: np.ndarray    # 车道点云 N×3
    noise: np.ndarray     # 每个点的噪声估计
    ctrl_pts: LinkedPoints # 控制点（仅地图中的车道）

# 帧
class Frame:
    frame_id: int         # 帧ID
    T_wc: np.ndarray      # 位姿 4×4
    lane_features: List[LaneFeature]  # 观测到的车道
```

### 1.3 因子图构建完整流程

```
map_update()
  ├─ add_keyframe()          # 添加关键帧到滑动窗口
  ├─ update_pose()           # (可选) 更新位姿
  ├─ build_graph()           # 构建因子图 ★核心★
  │   ├─ create_new_lane()   # 创建新车道
  │   ├─ 收集滑动窗口内的地标
  │   ├─ 点-曲线数据关联
  │   │   └─ find_footpoint() # 找到最近的4个控制点和参数u
  │   ├─ 创建因子
  │   │   └─ lane_factor()    # 点到样条因子
  │   └─ 添加约束因子
  │       ├─ add_chordal_factor() # 弦长约束
  │       └─ add_ctrl_factor()    # 控制点先验
  ├─ optimization()          # 执行优化
  │   ├─ 高斯-牛顿法迭代
  │   └─ 更新控制点
  └─ slide_window()          # 滑动窗口管理
```

### 1.4 中间变量说明

| 变量名 | 类型 | 含义 | 生命周期 |
|--------|------|------|---------|
| `self.graph` | `NonlinearFactorGraph` | 因子图 | 每次优化重建 |
| `self.initial_estimate` | `Values` | 初始值 | 每次优化重建 |
| `self.lm_in_window` | `List[int]` | 窗口内车道ID | 当前帧 |
| `self.lane_grid` | `Dict` | 网格下采样缓存 | 当前帧 |
| `pts_cp` | `List` | 待加入因子的观测点 | build_graph函数内 |
| `key_status_cur` | `Dict` | 控制点观测统计 | build_graph函数内 |
| `self.factor_candidates` | `List` | 候选因子（iSAM模式） | 全局累积 |
| `self.key_in_graph` | `Dict` | GTSAM符号→Node映射 | 全局 |
| `self.lanes_in_map` | `Dict` | 全局车道地图 | 全局 |

---

## 2. 因子定义与数学原理

### 2.1 因子类型总览

| 因子类型 | 连接变量 | 约束类型 | 作用 | 实现函数 |
|---------|---------|---------|------|---------|
| 点到样条 | 4个控制点 | 单目观测 | 主要数据项，拟合观测点云 | `error_catmull_rom` |
| 点到切线 | 4个控制点 | 单目观测（鲁棒） | 抗深度误差 | `p2tan_catmull_rom` |
| 弦长约束 | 2个相邻控制点 | 几何约束 | 保持平滑、防止退化 | `chord_factor` |
| 位姿-点-切线 | 位姿+固定控制点 | 位姿优化 | 联合优化位姿和车道 | `PosePointTangentFactor` |
| 控制点先验 | 1个控制点 | 正则化 | 稳定优化，避免未约束变量 | `PriorFactorPoint3` |

### 2.2 Catmull-Rom样条数学基础

#### 曲线表示

给定4个连续控制点 $\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3$，参数 $u \in [0,1]$ 处的曲线点为：

$$\mathbf{C}(u) = \mathbf{u}^T \mathbf{M} \mathbf{P}$$

其中：
- $\mathbf{u} = [1, u, u^2, u^3]^T$ 是参数向量
- $\mathbf{M}$ 是Catmull-Rom基础矩阵：

$$\mathbf{M} = \begin{bmatrix}
0 & 1 & 0 & 0 \\
-\tau & 0 & \tau & 0 \\
2\tau & \tau-3 & 3-2\tau & -\tau \\
-\tau & 2-\tau & \tau-2 & \tau
\end{bmatrix}$$

- $\mathbf{P} = [\mathbf{P}_0^T, \mathbf{P}_1^T, \mathbf{P}_2^T, \mathbf{P}_3^T]^T \in \mathbb{R}^{4 \times 3}$
- $\tau$ 是张力参数（默认0.5）

#### 切向量

$$\mathbf{C}'(u) = [0, 1, 2u, 3u^2] \mathbf{M} \mathbf{P}$$

归一化后：
$$\mathbf{d}(u) = \frac{\mathbf{C}'(u)}{||\mathbf{C}'(u)||}$$

### 2.3 点到样条因子

**误差函数**：
$$\mathbf{e}_{spline} = \mathbf{p}_{obs} - \mathbf{C}(u; \mathbf{P})$$

其中：
- $\mathbf{p}_{obs}$：观测点（世界坐标系）
- $\mathbf{C}(u)$：由4个控制点插值的曲线点

**插值展开**：
$$\mathbf{C}(u) = \sum_{i=0}^{3} c_i(u) \mathbf{P}_i$$

系数：
$$\mathbf{c}(u) = \mathbf{u}^T \mathbf{M} = [c_0(u), c_1(u), c_2(u), c_3(u)]$$

**雅可比矩阵**：
$$\frac{\partial \mathbf{e}}{\partial \mathbf{P}_i} = -c_i(u) \mathbf{I}_{3 \times 3}$$

**代码实现**：
```python
def error_catmull_rom(measurement, this, values, jacobians):
    # measurement = [x, y, z, u]
    ctrl_pts = [values.atPoint3(this.keys()[i]) for i in range(4)]
    ctrl_pts = np.concatenate(ctrl_pts).reshape(4,3)
    
    spline = CatmullRomSpline(ctrl_pts)
    u = measurement[3]
    
    # 计算曲线点和系数
    est_pt, coeff = spline.get_point(u, return_coeff=True)
    
    # 误差 = 观测点 - 曲线点
    error = (est_pt - measurement[:3]).reshape(3,1)
    
    # 雅可比
    if jacobians is not None:
        for i in range(4):
            jacobians[i] = np.eye(3) * coeff[i]
    
    return error
```

### 2.4 点到切线因子

**投影矩阵**：
$$\mathbf{\Pi}_{\perp}(u) = \mathbf{I}_{3 \times 3} - \mathbf{d}(u) \mathbf{d}(u)^T$$

**误差函数**（只保留垂直分量）：
$$\mathbf{e}_{tangent} = \mathbf{\Pi}_{\perp}(u) (\mathbf{p}_{obs} - \mathbf{C}(u))$$

**优点**：
- 单目深度估计误差大（沿车道方向）
- 横向误差更可靠（垂直于车道）
- 投影后只惩罚横向+高度误差

**几何示意**：
```
      观测点 p_obs
         ●
        ╱│╲
       ╱ │ ╲ d_perp（垂直距离）
      ╱  │   ╲
     ╱   ↓    ╲
────●─────────→●───  曲线
   C(u)   切向量 d(u)
```

**代码实现**：
```python
def p2tan_catmull_rom(measurement, this, values, jacobians):
    ctrl_pts = [values.atPoint3(this.keys()[i]) for i in range(4)]
    ctrl_pts = np.concatenate(ctrl_pts).reshape(4,3)
    
    spline = CatmullRomSpline(ctrl_pts)
    u = measurement[3]
    
    est_pt, coeff = spline.get_point(u, return_coeff=True)
    di = spline.get_derivative(u).reshape(3, 1)  # 切向量
    
    p2p = (measurement[:3] - est_pt).reshape(3,1)
    proj = np.eye(3) - di @ di.T  # 投影矩阵
    error = proj @ p2p  # 投影到垂直平面
    
    if jacobians is not None:
        for i in range(4):
            jacobians[i] = -proj * coeff[i]
    
    return error
```

### 2.5 弦长约束因子

**误差函数**：
$$e_{chord} = ||\mathbf{P}_i - \mathbf{P}_j|| - d_{chord}$$

其中 $d_{chord}$ 是期望的控制点间距（配置为5m）。

**作用**：
- 保持控制点间距均匀
- 防止控制点聚集退化
- 维持曲线平滑性

**实现**（使用BetweenFactor）：
```python
# add_chordal_factor函数
noise_model = self.get_pt_noise_model(1, huber=False, dim=3)
meas = self.key_in_graph[key_pair[1]].item - self.key_in_graph[key_pair[0]].item
self.graph.add(gtsam.BetweenFactorPoint3(key_pair[0], key_pair[1], meas, noise_model))
```

### 2.6 控制点先验因子

**触发条件**：
```python
if obs[0] < 4 or obs[1] < 1:  # 观测次数不足
    key_unstable.append(key)
```

**误差函数**：
$$\mathbf{e}_{prior} = \mathbf{P}_i - \mathbf{P}_i^{init}$$

**作用**：
- 对不稳定控制点添加软约束
- 避免优化过程中的数值不稳定
- 正则化作用，防止过拟合

---

## 3. 优化系统构建流程

### 3.1 数据关联详解

**目标**：将观测点 $\mathbf{p}_w$ 关联到地图车道的4个控制点。

**Step 1：KDTree最近邻搜索**
```python
def find_footpoint(self, point):
    # 1. KDTree找2个最近控制点
    dist, idx = self.kdtree.query(point, k=2)
    
    # 2. 检查距离和连续性
    if (dist > chord_threshold).any(): return None
    if abs(idx[0] - idx[1]) > 1: return None  # 必须连续
    
    # 3. 构造4个控制点（需要前后各扩展1个）
    idx1, idx2 = min(idx), max(idx)
    ctrl_pts = [node[idx1-1], node[idx1], node[idx2], node[idx2+1]]
    
    # 4. 参数化：计算u值
    u, error = parameterization(point, ctrl_pts_np)
    
    return ctrl_pts, u, error
```

**Step 2：参数化（计算u）**
```python
def parameterization(pt_w, ctrl_pts_np, tau=0.5, N=4):
    # 1. 生成曲线上的锚点
    spline = CatmullRomSpline(ctrl_pts_np, tau)
    anchors = spline.get_points(N, return_knots=True)
    # anchors = [[x,y,z,u], ...] (N×4)
    
    # 2. 找到包围pt_w的两个锚点
    dist, idx = knn(pt_w, anchors[:,:3], k=2)
    pt1, pt2 = anchors[min(idx)], anchors[max(idx)]
    
    # 3. 线性插值计算u
    v1 = pt2[:3] - pt1[:3]
    v2 = pt_w[:3] - pt1[:3]
    ratio = np.dot(v1, v2.T) / np.sum(v1**2)
    u = pt1[3] + ratio * (pt2[3] - pt1[3])
    
    # 4. 验证并计算投影误差
    est_pt = spline.get_point(u)
    error = np.linalg.norm(pt_w[:3] - est_pt)
    
    return u, error
```

**参数u的作用**：
1. **确定插值系数**：$\mathbf{c}(u) = [1, u, u^2, u^3] \mathbf{M}$
2. **计算雅可比**：$\frac{\partial \mathbf{e}}{\partial \mathbf{P}_i} = -c_i(u) \mathbf{I}$
3. **建立观测-控制点对应**：明确观测点在曲线上的位置

### 3.2 因子创建流程

```python
# build_graph函数核心循环
for frame in self.sliding_window:
    for lf in frame.get_lane_features():  # 每条观测车道
        lm = self.lanes_in_map[lf.id]  # 地图中的车道
        
        for pt_c in lf.get_xyzs():  # 每个观测点
            # 1. 转世界坐标
            pt_w = frame.T_wc[:3,:3] @ pt_c[:3] + frame.T_wc[:3,3]
            
            # 2. 数据关联
            ctrl_pts, u, error = lm.ctrl_pts.find_footpoint(pt_w)
            
            # 3. 检查关联质量
            if ctrl_pts is None or error > 10.0 or u < 0 or u > 1:
                continue
            
            # 4. 网格下采样（滑动窗口模式）
            if not self.use_isam:
                interval_id = int(u * lane_sample_num)
                if lf.noise[j] < self.lane_grid[...][interval_id][-1]:
                    self.lane_grid[...][interval_id] = [pt_w, pt_c, ctrl_pts, ...]
            
            # 5. 设置GTSAM符号
            for ctrl_pt in ctrl_pts:
                in_graph = self.set_gtsam_symbol(lm_id, ctrl_pt.id, ctrl_pt)
                if not in_graph:
                    self.initial_estimate.insert(ctrl_pt.get_key(), 
                                                 gtsam.Point3(ctrl_pt.item))
            
            # 6. 创建因子
            pt_w_u = np.concatenate((pt_w, [u]))
            gf = self.lane_factor(pt_w_u, pt_c, u, ctrl_pts, noise, frame_id)
            self.factor_candidates.append([gf, ...])
```

### 3.3 优化执行

**高斯-牛顿法**：

迭代求解：
$$\mathbf{H} \Delta \mathbf{P} = -\mathbf{b}$$

其中：
- $\mathbf{H} = \sum_k \mathbf{J}_k^T \Sigma_k^{-1} \mathbf{J}_k$：Hessian矩阵
- $\mathbf{b} = \sum_k \mathbf{J}_k^T \Sigma_k^{-1} \mathbf{e}_k$：梯度
- $\mathbf{J}_k$：第k个因子的雅可比矩阵

**更新**：
$$\mathbf{P} \leftarrow \mathbf{P} + \Delta \mathbf{P}$$

**代码实现**：
```python
def optimization(self):
    if self.use_isam:
        # 增量式优化
        self.isam.update(self.graph, self.initial_estimate)
        result = self.isam.calculateEstimate()
    else:
        # 批量优化
        params = gtsam.GaussNewtonParams()
        params.setMaxIterations(5)
        optimizer = gtsam.GaussNewtonOptimizer(self.graph, 
                                               self.initial_estimate, params)
        result = optimizer.optimize()
    
    # 更新控制点
    for key in result.keys():
        if key in self.key_in_graph.keys():
            node = self.key_in_graph[key]
            node.set_item(result.atPoint3(key))
    
    # 平滑曲线
    for lane in self.lanes_in_map.values():
        lane.smooth()
```

### 3.4 优化目标函数

**完整形式**：
$$\mathbf{P}^* = \arg\min_{\mathbf{P}} \sum_{k=1}^{K} \rho_k\left( ||\mathbf{e}_k(\mathbf{P})||_{\Sigma_k}^2 \right)$$

**各项解释**：

1. **马氏距离平方**：
$$||\mathbf{e}_k||_{\Sigma_k}^2 = \mathbf{e}_k^T \Sigma_k^{-1} \mathbf{e}_k$$

2. **鲁棒核函数**（Huber）：
$$\rho(s) = \begin{cases}
s & \text{if } s \leq \delta^2 \\
2\delta\sqrt{s} - \delta^2 & \text{if } s > \delta^2
\end{cases}$$

**计算示例**：
```python
# 一个因子的代价
e = [0.2, -0.1, 0.1]  # 误差向量
Sigma_inv = 4 * I     # 信息矩阵（σ=0.5）
s = e.T @ Sigma_inv @ e = 0.24  # 马氏距离平方
rho(s) = 0.24  # Huber核（s < δ²）

# 总代价
total_cost = Σ_{k=1}^{100} ρ_k(s_k)
```

---

## 4. 数据流与信息使用

### 4.1 完整数据流图

```
感知输入                      数据关联                     因子图优化
┌──────────┐               ┌──────────┐               ┌──────────┐
│ xyz      │──初始化控制点──→│ ctrl_pts │──插值C(u)────→│ 误差e(P) │
│ track_id │──建立对应关系──→│ lane_id  │               │          │
│ noise    │──设置权重──────→│ Σ_k      │──马氏距离────→│ ||e||²_Σ │
│ category │               │          │               │          │
└──────────┘               │          │               │          │
                           │ u参数    │──系数c(u)────→│ 雅可比J  │
                           └──────────┘               └──────────┘
                                                            │
                                                            ▼
                                                      ┌──────────┐
                                                      │ GTSAM求解│
                                                      │ ΔP = H⁻¹b│
                                                      └──────────┘
                                                            │
                                                            ▼
                                                      ┌──────────┐
                                                      │优化后控制点│
                                                      │  P* = P+ΔP│
                                                      └──────────┘
                                                            │
                                                            ▼
                                                      ┌──────────┐
                                                      │曲线平滑   │
                                                      │C*(u)重插值│
                                                      └──────────┘
```

### 4.2 感知数据使用

| 信息 | 使用方式 | 作用 |
|------|---------|------|
| xyz（3D点） | 初始化控制点、优化时作为观测 | 主要约束 |
| track_id | 数据关联（辅助） | 帮助识别车道 |
| category | 区分车道类型 | 语义约束（可选） |
| visibility | 计算测量噪声 | 权重设置 |

**噪声计算**：
```python
def compute_noise(self, xyz):
    # 距离越远，噪声越大
    dist2 = xyz[:,0]**2 + xyz[:,1]**2
    ratio = np.sqrt(dist2 / max_range2)
    noise = lower_bound + (upper_bound - lower_bound) * ratio
    return noise
```

### 4.3 Catmull-Rom曲线信息使用

| 信息 | 来源 | 使用 |
|------|------|------|
| 控制点P | 初始：感知点云下采样<br>优化：GTSAM变量 | 曲线插值、误差计算、雅可比 |
| 参数u | 通过锚点参数化计算 | 确定观测点位置、计算系数 |
| 张力τ | 配置文件（默认0.5） | 基矩阵M |
| 切向量C'(u) | 基于控制点计算 | 点到切线因子、退化检测 |

### 4.4 观测点采样策略

**多级下采样**：
```
原始感知点（~100个/车道）
      ↓ 体素下采样（voxel_size=0.3m）
观测点（~30个）
      ↓ 网格采样（按u值分10个区间）
最终用于因子的点（~10个）
```

**网格采样代码**：
```python
interval_id = np.clip(int(u * cfg.lane_mapping.lane_sample_num), 0, 
                      cfg.lane_mapping.lane_sample_num - 1)
# 只保留每个u区间内噪声最小的点
if lf.noise[j] < self.lane_grid[lm_id][ctrl_pt.id][interval_id][-1]:
    self.lane_grid[lm_id][ctrl_pt.id][interval_id] = [pt_w, ...]
```

### 4.5 Track_ID vs 全局ID

| ID类型 | 来源 | 作用域 | 持久性 | 可靠性 |
|--------|------|--------|--------|--------|
| track_id | 感知模型 | 连续帧 | 容易中断 | 依赖检测 |
| 全局ID | SLAM关联 | 整个地图 | 持久 | 几何验证 |

**关联流程**：
```python
def lane_association(self):
    # 基于几何距离的关联（独立于track_id）
    A, stats = self.assoc_model.association()
    
    for i in range(len(det_list)):
        if i in A[:, 1]:  # 匹配成功
            j = A[A[:, 1] == i, 0][0]
            det_list[i].id = lm_list[j].id  # 使用地图ID
        elif det_list[i].self_check():  # 新车道
            det_list[i].id = self.max_lane_id + 1
            self.max_lane_id += 1
```

---

## 5. EKF与因子图对比

### 5.1 核心差异

| 特性 | EKF | 因子图 |
|------|-----|--------|
| **历史观测** | 丢弃（边缘化） | 保留 |
| **线性化点** | 当前预测状态（一次） | 迭代更新（多次） |
| **状态修正** | 只修正当前状态 | 可修正所有历史状态 |
| **回环检测** | 困难 | 自然支持 |
| **计算复杂度** | O(n²) | O(n)（稀疏）或O(n³) |
| **内存需求** | 低 | 高 |

### 5.2 线性化对比

**EKF线性化**：
```python
# 每步只线性化一次
x_pred = f(x_k, u_k)
F = jacobian(f, x_pred)  # 在x_pred处
P_pred = F @ P_k @ F.T + Q

# 线性化点x_pred使用后即丢弃
```

**因子图线性化**：
```python
# 迭代更新线性化点
x = x_init
for iter in range(max_iter):
    # 在当前x处重新线性化所有因子
    H, b = 0, 0
    for factor in graph:
        e = factor.error(x)
        J = factor.jacobian(x)  # 在当前x处
        H += J.T @ Sigma_inv @ J
        b += J.T @ Sigma_inv @ e
    
    delta_x = -inv(H) @ b
    x = x + delta_x  # 更新线性化点
```

### 5.3 为什么车道SLAM不用EKF

**1. 累积误差问题**：
```
EKF在车道SLAM：
时刻1: 建立车道地图 → 地图有误差ε₁
时刻2: 基于错误地图定位 → ε₁+ε₂
时刻3: 继续累积 → ε₁+ε₂+ε₃
...
时刻100: 回环时已偏离太远，无法闭环
```

**2. 无绝对观测**：
```
组合导航（EKF可行）：
DR（漂移） + GPS（绝对位置） → 定期重置误差

车道SLAM（EKF困难）：
只有相对观测（点到车道距离）
无法"重置"累积误差
```

**3. 地图-定位耦合**：
```
EKF：地图误差 → 定位误差 → 更大地图误差（恶性循环）
因子图：全局优化，均匀分配误差
```

### 5.4 优化范围对比

**iSAM2模式**（本项目默认）：
```python
self.use_isam = True
# 保留所有历史状态
# 通过贝叶斯树增量更新
# 优化范围：全局（0-10km）
# 计算复杂度：增量 O(k³)，k << n
```

**滑动窗口模式**：
```python
self.use_isam = False
self.window_size = 10  # 最近10帧
# 优化范围：局部（窗口内帧观测到的车道）
# 窗口外地图固定不变
```

**实际优化范围**：
```
滑动窗口示例（10帧，车速10m/s，帧率10Hz）：
窗口时间跨度 = 10帧 / 10Hz = 1秒
车辆移动距离 = 10m/s × 1s = 10m

但优化的车道长度：
= 窗口内帧的累积视野
= 10m（车辆移动）+ 60m（前视范围）
≈ 70m+

因此"滑动窗口100m"是粗略估计
```

---

## 6. 高级主题与实现细节

### 6.1 鲁棒核函数（Huber）

**作用**：处理外点（outliers）。

**数学定义**：
$$\rho(s) = \begin{cases}
s & \text{if } s \leq \delta^2 \\
2\delta\sqrt{s} - \delta^2 & \text{if } s > \delta^2
\end{cases}$$

**效果对比**：
```
普通最小二乘：
cost = Σ error²
一个大外点 error=100m → cost ≈ 10000（主导优化）

Huber核（δ=1m）：
ρ(10000) ≈ 2×1×100 - 1 = 199（线性增长）
外点影响被抑制
```

**实现**：
```python
def get_pt_noise_model(self, noise, huber=False, huber_thresh=1.0):
    ctrlpt_noise_model = gtsam.noiseModel.Isotropic.Sigma(dim, noise)
    if huber:
        ctrlpt_noise_model = gtsam.noiseModel.Robust.Create(
            gtsam.noiseModel.mEstimator.Huber(huber_thresh),
            ctrlpt_noise_model)
    return ctrlpt_noise_model
```

### 6.2 回环检测支持

**iSAM2模式的优势**：
```python
# 保留所有历史信息
self.lanes_in_map = {}      # 所有车道（0-10km）
self.key_in_graph = {}      # 所有控制点

def get_candi_lanes(self, frame):
    return list(self.lanes_in_map.values())  # 返回所有车道

# 10km后回到起点
# 数据关联会自动找到起点车道
# 建立回环约束
# iSAM2重新优化全局状态
```

**滑动窗口的局限**：
```python
# 只保存最近10帧
self.sliding_window = [frame_995, ..., frame_1005]

# 问题：起点地图（frame_0）已移出窗口
# 无法建立回环约束
```

### 6.3 位姿更新与退化检测

**退化问题**：单目车道观测无法约束沿车道方向的运动。

**解决方案**：
```python
if cfg.pose_update.reproject and len(directions) > 0:
    # 1. 计算平均车道方向（退化方向）
    degeneracy_d = np.hstack(directions).mean(axis=1)
    degeneracy_d /= np.linalg.norm(degeneracy_d)
    
    # 2. 投影矩阵（移除退化方向的更新）
    proj = np.eye(3) - degeneracy_d @ degeneracy_d.T
    
    # 3. 位置更新
    update_xyz = update_pose[:3, 3]
    nex_xyz = proj @ update_xyz  # 移除沿车道方向的更新
    update_pose[:3, 3] = nex_xyz
```

### 6.4 因子图的"二分图"含义

**图论定义**：图的节点可分为两类，边只连接不同类的节点。

**因子图中的两类节点**：
1. **变量节点**（圆形）：待优化的状态（控制点、位姿）
2. **因子节点**（方形）：约束/观测（误差函数）

**示意图**：
```
变量节点          因子节点          变量节点
   P₀  ────────── f₁ ──────────  P₁
   │               │               │
   │               │               │
   │              f₂               │
   │               │               │
   P₂  ────────── f₃ ──────────  P₃
```

**特点**：
- 因子只连接变量（不连接其他因子）
- 变量只通过因子间接连接

### 6.5 CatmullRomSpline完整实现

**输入**：
```python
ctrl_pts = np.array([[0,0,0], [5,1,0], [10,0,0], [15,-1,0]])  # (4,3)
tau = 0.5
```

**核心方法**：

| 方法 | 输入 | 输出 | 用途 |
|------|------|------|------|
| `__init__` | 控制点(4,3), τ | 初始化M矩阵 | 构造 |
| `get_points(num)` | 采样数num | 曲线点(num,3) | 可视化 |
| `get_point(u)` | 参数u | 单个点(3,) | 插值 |
| `get_point(u, True)` | 参数u | 点(3,), 系数(4,) | 优化（需要系数计算雅可比） |
| `get_derivative(u)` | 参数u | 单位切向量(3,) | 点到切线因子 |

**数值示例**（τ=0.5, u=0.5）：
```python
# 基矩阵
M = [[0,   1,    0,     0  ],
     [-0.5, 0,    0.5,   0  ],
     [1,   -2.5,  2,    -0.5],
     [-0.5, 1.5, -1.5,   0.5]]

# 系数
u_vec = [1, 0.5, 0.25, 0.125]
coeff = u_vec @ M = [-0.0625, 0.5625, 0.5625, -0.0625]

# 曲线点
C(0.5) = Σ coeff[i] * P[i] = [7.5, 0.625, 0]

# 切向量
u_vec_deriv = [0, 1, 1, 0.375]
C'(0.5) = [9.6875, -1.25, 0]（未归一化）
```

---

## 7. 常见问题解答

### Q1：锚点（Anchors）是什么？

**A**：锚点是曲线上的采样点，**仅用于计算参数u**，不参与误差计算。

```
观测点 pt_w → 找包围的两个锚点 → 插值得到u → 锚点使命完成
                                      ↓
                              u用于计算C(u)和雅可比
```

### Q2：误差是"控制点 vs 锚点"吗？

**A**：不是！误差是**观测点 vs 曲线插值点**。

$$\mathbf{e} = \mathbf{p}_{obs} - \mathbf{C}(u; \mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3)$$

### Q3：滑动窗口的"100m"是什么意思？

**A**：这是粗略估计。实际优化的是**窗口内帧观测到的车道**，范围取决于：
- 窗口帧数
- 每帧视野范围
- 车辆移动距离

例如10帧窗口，车辆移动10m，但每帧视野60m，实际优化范围可达70m+。

### Q4：因子图会优化整个10km地图吗？

**A**：取决于模式：
- **iSAM2模式**（默认）：优化全局，但增量更新只计算变化部分
- **滑动窗口模式**：只优化窗口内车道，窗口外固定

### Q5：参数u的物理意义是什么？

**A**：$u \in [0,1]$ 表示观测点在$\mathbf{P}_1$到$\mathbf{P}_2$曲线段上的相对位置。
- $u=0$ → 在$\mathbf{P}_1$处
- $u=0.5$ → 在曲线中点
- $u=1$ → 在$\mathbf{P}_2$处

---

## 8. 参考资料

### 代码文件导航

| 文件 | 核心内容 |
|------|---------|
| `lane_slam/factors.py` | 因子误差函数定义 |
| `lane_slam/system/lane_opt.py` | 因子图构建与优化 |
| `misc/curve/catmull_rom.py` | Catmull-Rom样条实现 |
| `lane_slam/linked_points.py` | 控制点链表与KDTree |
| `lane_slam/frame.py` | 帧数据结构 |
| `lane_slam/lane_feature.py` | 车道特征与控制点管理 |

### 关键配置参数

```yaml
# config/lane_mapping.yaml
lane_mapping:
  ctrl_points_chord: 5.0        # 控制点间距(m)
  tau: 0.5                       # Catmull-Rom张力
  window_size: 10                # 滑动窗口大小
  lane_sample_num: 10            # 网格采样区间数
  lane_meas_noise: [0.3, 2.0]    # 测量噪声范围(m)
  ctrl_noise: [0.5, 0.5, 0.5]    # 控制点先验噪声(m)
```

### 论文参考

- **Online Monocular Lane Mapping Using Catmull-Rom Spline** (附带的PDF文档)
- GTSAM库文档：https://gtsam.org/
- iSAM2原理：Kaess et al., "iSAM2: Incremental Smoothing and Mapping Using the Bayes Tree", IJRR 2012

---

**文档版本**：v1.0  
**最后更新**：2025-12-17  
**作者**：根据项目代码和技术讨论整理
