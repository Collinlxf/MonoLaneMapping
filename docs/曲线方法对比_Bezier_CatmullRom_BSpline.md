# æ›²çº¿æ–¹æ³•å¯¹æ¯”: BÃ©zier vs Catmull-Rom vs B-Spline

## ç›®å½•
1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [ä¸‰ç§æ›²çº¿çš„æ•°å­¦åŸç†](#ä¸‰ç§æ›²çº¿çš„æ•°å­¦åŸç†)
3. [æ ¸å¿ƒåŒºåˆ«å¯¹æ¯”](#æ ¸å¿ƒåŒºåˆ«å¯¹æ¯”)
4. [**ä¸‰ç§æ›²çº¿çš„ç»Ÿä¸€è¡¨ç¤ºä¸ç›¸äº’è½¬æ¢**](#ä¸‰ç§æ›²çº¿çš„ç»Ÿä¸€è¡¨ç¤ºä¸ç›¸äº’è½¬æ¢) â­ **NEW**
5. [å®ç°åŸç†è¯¦è§£](#å®ç°åŸç†è¯¦è§£)
6. [åº”ç”¨åœºæ™¯åˆ†æ](#åº”ç”¨åœºæ™¯åˆ†æ)
7. [ä¸ºä»€ä¹ˆè½¦é“SLAMé€‰æ‹©Catmull-Rom](#ä¸ºä»€ä¹ˆè½¦é“slamé€‰æ‹©catmull-rom)
8. [æœ¬é¡¹ç›®ä¸­Catmull-Romæ§åˆ¶ç‚¹çš„é€‰å–ç®—æ³•](#æœ¬é¡¹ç›®ä¸­catmull-romæ§åˆ¶ç‚¹çš„é€‰å–ç®—æ³•)
9. [ä¸‰ç§æ›²çº¿åœ¨è‡ªåŠ¨é©¾é©¶ä¸­çš„åº”ç”¨åœºæ™¯](#ä¸‰ç§æ›²çº¿åœ¨è‡ªåŠ¨é©¾é©¶ä¸­çš„åº”ç”¨åœºæ™¯)
10. [ä»£ç ç¤ºä¾‹](#ä»£ç ç¤ºä¾‹)
11. [å‚è€ƒèµ„æ–™](#å‚è€ƒèµ„æ–™)

---

## æ¦‚è¿°

åœ¨è®¡ç®—æœºå›¾å½¢å­¦å’Œæ›²çº¿æ‹Ÿåˆä¸­,**BÃ©zieræ›²çº¿**ã€**Catmull-Romæ ·æ¡** å’Œ **B-Spline** æ˜¯ä¸‰ç§æœ€å¸¸ç”¨çš„å‚æ•°æ›²çº¿æ–¹æ³•ã€‚è™½ç„¶å®ƒä»¬éƒ½ä½¿ç”¨æ§åˆ¶ç‚¹æ¥å®šä¹‰æ›²çº¿,ä½†åœ¨**æ•°å­¦åŸç†ã€æ›²çº¿æ€§è´¨å’Œåº”ç”¨åœºæ™¯**ä¸Šæœ‰æœ¬è´¨åŒºåˆ«ã€‚

### å¿«é€Ÿå¯¹æ¯”

| ç‰¹æ€§ | BÃ©zieræ›²çº¿ | Catmull-Romæ ·æ¡ | B-Spline |
|------|-----------|----------------|----------|
| **å‘æ˜å¹´ä»£** | 1962 (Pierre BÃ©zier) | 1974 (Catmull & Rom) | 1946 (Schoenberg) |
| **æ˜¯å¦é€šè¿‡æ§åˆ¶ç‚¹** | âŒ ä»…é€šè¿‡ç«¯ç‚¹ | âœ… é€šè¿‡æ‰€æœ‰æ§åˆ¶ç‚¹ | âŒ ä¸é€šè¿‡æ§åˆ¶ç‚¹ |
| **æ›²çº¿ç±»å‹** | é€¼è¿‘ | **æ’å€¼** | é€¼è¿‘ |
| **è¿ç»­æ€§** | Câ° (åˆ†æ®µ) | **CÂ¹** | **CÂ²** |
| **å±€éƒ¨æ€§** | âŒ å…¨å±€å½±å“ | âœ… å±€éƒ¨å½±å“ | âœ… å±€éƒ¨å½±å“ |
| **å‚æ•°** | æ¬¡æ•°(n) | å¼ åŠ›tau | èŠ‚ç‚¹å‘é‡ |
| **è®¡ç®—å¤æ‚åº¦** | O(nÂ²) | **O(1)** | O(n) |

---

## ä¸‰ç§æ›²çº¿çš„æ•°å­¦åŸç†

### 1. BÃ©zier æ›²çº¿

**æ•°å­¦å®šä¹‰**:
$$
\mathbf{B}(t) = \sum_{i=0}^{n} \mathbf{P}_i \cdot B_{i,n}(t), \quad t \in [0,1]
$$

å…¶ä¸­ $B_{i,n}(t)$ æ˜¯ **ä¼¯æ©æ–¯å¦åŸºå‡½æ•°**:
$$
B_{i,n}(t) = \binom{n}{i} t^i (1-t)^{n-i}
$$

**æ ¸å¿ƒç‰¹ç‚¹**:
- ä½¿ç”¨**ä¼¯æ©æ–¯å¦å¤šé¡¹å¼**ä½œä¸ºåŸºå‡½æ•°
- æ›²çº¿æ¬¡æ•° = æ§åˆ¶ç‚¹æ•°é‡ - 1
- **å…¨å±€æ€§**: ä¿®æ”¹ä»»ä¸€æ§åˆ¶ç‚¹ä¼šå½±å“æ•´æ¡æ›²çº¿
- **å‡¸åŒ…æ€§è´¨**: æ›²çº¿å®Œå…¨ä½äºæ§åˆ¶ç‚¹çš„å‡¸åŒ…å†…
- **ç«¯ç‚¹æ’å€¼**: æ›²çº¿é€šè¿‡é¦–å°¾æ§åˆ¶ç‚¹ $\mathbf{P}_0$ å’Œ $\mathbf{P}_n$

**çŸ©é˜µå½¢å¼** (ä¸‰æ¬¡BÃ©zier):
$$
\mathbf{B}(t) = 
\begin{bmatrix} 1 & t & t^2 & t^3 \end{bmatrix}
\begin{bmatrix} 
1 & 0 & 0 & 0 \\
-3 & 3 & 0 & 0 \\
3 & -6 & 3 & 0 \\
-1 & 3 & -3 & 1
\end{bmatrix}
\begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}
$$

---

### 2. Catmull-Rom æ ·æ¡

**æ•°å­¦å®šä¹‰**:

å¯¹äº4ä¸ªæ§åˆ¶ç‚¹ $\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3$,æ›²çº¿æ®µå®šä¹‰ä¸º:
$$
\mathbf{C}(t) = 
\begin{bmatrix} 1 & t & t^2 & t^3 \end{bmatrix}
\mathbf{M}_{CR}
\begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}
, \quad t \in [0,1]
$$

**Catmull-Rom åŸºç¡€çŸ©é˜µ**:
$$
\mathbf{M}_{CR} = 
\begin{bmatrix}
0 & 1 & 0 & 0 \\
-\tau & 0 & \tau & 0 \\
2\tau & \tau-3 & 3-2\tau & -\tau \\
-\tau & 2-\tau & \tau-2 & \tau
\end{bmatrix}
$$

**å‚æ•°è¯´æ˜**:
- $\tau$ (tau): **å¼ åŠ›å‚æ•°**,é€šå¸¸å–0.5
  - $\tau = 0$: æ›²çº¿é€€åŒ–ä¸ºç›´çº¿
  - $\tau = 0.5$: æ ‡å‡†Catmull-Romæ ·æ¡
  - $\tau \to 1$: æ›²çº¿æ›´åŠ æ¾å¼›

**æ ¸å¿ƒç‰¹ç‚¹**:
- **æ’å€¼æ€§è´¨**: æ›²çº¿ç²¾ç¡®é€šè¿‡ $\mathbf{P}_1$ å’Œ $\mathbf{P}_2$
- **å±€éƒ¨æ€§**: ä¿®æ”¹ä¸€ä¸ªæ§åˆ¶ç‚¹åªå½±å“ç›¸é‚»çš„4ä¸ªæ§åˆ¶ç‚¹èŒƒå›´
- **CÂ¹è¿ç»­**: ä½ç½®å’Œå¯¼æ•°è¿ç»­,ä½†æ›²ç‡å¯èƒ½ä¸è¿ç»­
- **æ— éœ€é¢å¤–ç«¯ç‚¹**: $\mathbf{P}_0$ å’Œ $\mathbf{P}_3$ ç”¨äºå®šä¹‰åˆ‡çº¿æ–¹å‘

---

### 3. B-Spline (åŸºæ ·æ¡)

**æ•°å­¦å®šä¹‰**:
$$
\mathbf{S}(t) = 
\begin{bmatrix} t^3 & t^2 & t & 1 \end{bmatrix}
\mathbf{M}_{BS}
\begin{bmatrix} \mathbf{P}_i \\ \mathbf{P}_{i+1} \\ \mathbf{P}_{i+2} \\ \mathbf{P}_{i+3} \end{bmatrix}
, \quad t \in [0,1]
$$

**ä¸‰æ¬¡B-SplineåŸºç¡€çŸ©é˜µ**:
$$
\mathbf{M}_{BS} = \frac{1}{6}
\begin{bmatrix}
-1 & 3 & -3 & 1 \\
3 & -6 & 3 & 0 \\
-3 & 0 & 3 & 0 \\
1 & 4 & 1 & 0
\end{bmatrix}
$$

**æ ¸å¿ƒç‰¹ç‚¹**:
- **é€¼è¿‘æ€§**: æ›²çº¿**ä¸é€šè¿‡æ§åˆ¶ç‚¹**,è€Œæ˜¯è¢«æ§åˆ¶ç‚¹"å¸å¼•"
- **CÂ²è¿ç»­**: ä½ç½®ã€å¯¼æ•°ã€æ›²ç‡éƒ½è¿ç»­,**æœ€å¹³æ»‘**
- **å±€éƒ¨æ§åˆ¶**: ä¿®æ”¹ä¸€ä¸ªæ§åˆ¶ç‚¹åªå½±å“å±€éƒ¨æ›²çº¿æ®µ
- **å‡¸åŒ…æ€§è´¨**: æ¯æ®µæ›²çº¿éƒ½åœ¨4ä¸ªæ§åˆ¶ç‚¹çš„å‡¸åŒ…å†…
- **æ•°å€¼ç¨³å®š**: å¯¹æ§åˆ¶ç‚¹æ‰°åŠ¨ä¸æ•æ„Ÿ

---

## æ ¸å¿ƒåŒºåˆ«å¯¹æ¯”

### 1. æ’å€¼ vs é€¼è¿‘

**æœ€å…³é”®çš„åŒºåˆ«**:

```
æ§åˆ¶ç‚¹åºåˆ—: P0 --- P1 --- P2 --- P3 --- P4

BÃ©zier:      â—-----â—‹-----â—‹-----â—‹-----â—
             é€šè¿‡ç«¯ç‚¹,ä¸é€šè¿‡ä¸­é—´ç‚¹

Catmull-Rom: â—‹-----â—-----â—-----â—-----â—‹  
             é€šè¿‡P1,P2,P3,ä¸é€šè¿‡ç«¯ç‚¹

B-Spline:    â—‹--ï½--â—‹--ï½--â—‹--ï½--â—‹--ï½--â—‹
             ä¸é€šè¿‡ä»»ä½•æ§åˆ¶ç‚¹,æ›²çº¿åœ¨é™„è¿‘
```

### 2. è¿ç»­æ€§ç­‰çº§

| è¿ç»­æ€§ | å«ä¹‰ | BÃ©zier | Catmull-Rom | B-Spline |
|--------|------|--------|-------------|----------|
| **Câ°** | ä½ç½®è¿ç»­ | âœ… | âœ… | âœ… |
| **CÂ¹** | å¯¼æ•°è¿ç»­(åˆ‡çº¿) | âŒ* | âœ… | âœ… |
| **CÂ²** | æ›²ç‡è¿ç»­ | âŒ | âŒ | âœ… |

*æ³¨: åˆ†æ®µBÃ©zieråœ¨è¿æ¥å¤„å¯èƒ½ä¸è¿ç»­,éœ€è¦ç‰¹æ®Šæ„é€ æ‰èƒ½CÂ¹

### 3. å±€éƒ¨æ€§ vs å…¨å±€æ€§

**ä¿®æ”¹æ§åˆ¶ç‚¹Pâ‚‚çš„å½±å“èŒƒå›´**:

```
BÃ©zier (4æ¬¡):     [=================]  æ•´æ¡æ›²çº¿éƒ½å˜åŒ–
Catmull-Rom:      [====]               åªå½±å“ç›¸é‚»4ä¸ªç‚¹çš„èŒƒå›´  
B-Spline:         [======]             åªå½±å“ç›¸é‚»4ä¸ªç‚¹çš„èŒƒå›´
```

**ä¸ºä»€ä¹ˆé‡è¦?**
- âœ… **å±€éƒ¨æ€§å¥½**: è°ƒæ•´å±€éƒ¨å½¢çŠ¶ä¸å½±å“è¿œå¤„,é€‚åˆç¼–è¾‘å’Œä¼˜åŒ–
- âŒ **å…¨å±€æ€§**: éš¾ä»¥ç²¾ç¡®æ§åˆ¶å±€éƒ¨å½¢çŠ¶

### 4. è®¡ç®—æ•ˆç‡

å‡è®¾æœ‰ $n$ ä¸ªæ§åˆ¶ç‚¹:

| æ›²çº¿ç±»å‹ | å•ç‚¹è®¡ç®— | æ•´æ¡æ›²çº¿ | å†…å­˜å ç”¨ |
|---------|---------|---------|---------|
| BÃ©zier | O(n) | O(nÂ·m) | ä½ |
| Catmull-Rom | **O(1)** | **O(m)** | ä½ |
| B-Spline | O(1) | O(m) | ä¸­ |

å…¶ä¸­ $m$ æ˜¯é‡‡æ ·ç‚¹æ•°é‡

---

## ä¸‰ç§æ›²çº¿çš„ç»Ÿä¸€è¡¨ç¤ºä¸ç›¸äº’è½¬æ¢

### æ ¸å¿ƒæ€æƒ³: ç»Ÿä¸€çš„å‚æ•°æ›²çº¿æ¡†æ¶

è¿™ä¸‰ç§æ›²çº¿è™½ç„¶çœ‹èµ·æ¥ä¸åŒï¼Œä½†éƒ½å¯ä»¥ç”¨**ç»Ÿä¸€çš„çŸ©é˜µå½¢å¼**è¡¨ç¤ºï¼š

$$
\mathbf{C}(t) = \begin{bmatrix} 1 & t & t^2 & t^3 \end{bmatrix} \cdot \mathbf{M} \cdot \begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}, \quad t \in [0, 1]
$$

**å…³é”®åŒºåˆ«ä»…åœ¨äºåŸºç¡€çŸ©é˜µ $\mathbf{M}$**ï¼

### 1. ä¸‰ç§æ›²çº¿çš„åŸºç¡€çŸ©é˜µ

#### BÃ©zier æ›²çº¿åŸºç¡€çŸ©é˜µ

$$
\mathbf{M}_{Bezier} = \begin{bmatrix} 
1 & 0 & 0 & 0 \\
-3 & 3 & 0 & 0 \\
3 & -6 & 3 & 0 \\
-1 & 3 & -3 & 1
\end{bmatrix}
$$

**ç‰©ç†æ„ä¹‰**: ä¼¯æ©æ–¯å¦å¤šé¡¹å¼çš„ç³»æ•°

#### Catmull-Rom åŸºç¡€çŸ©é˜µ

$$
\mathbf{M}_{CR} = \frac{1}{2} \begin{bmatrix}
0 & 2 & 0 & 0 \\
-1 & 0 & 1 & 0 \\
2 & -5 & 4 & -1 \\
-1 & 3 & -3 & 1
\end{bmatrix} \quad (\tau = 0.5)
$$

**ç‰©ç†æ„ä¹‰**: é€šè¿‡ä¸­é—´ä¸¤ç‚¹çš„æ’å€¼æ ·æ¡

#### B-Spline åŸºç¡€çŸ©é˜µ (å‡åŒ€ä¸‰æ¬¡)

$$
\mathbf{M}_{BSpline} = \frac{1}{6} \begin{bmatrix}
1 & 4 & 1 & 0 \\
-3 & 0 & 3 & 0 \\
3 & -6 & 3 & 0 \\
-1 & 3 & -3 & 1
\end{bmatrix}
$$

**ç‰©ç†æ„ä¹‰**: å±€éƒ¨æ”¯æ’‘çš„Bæ ·æ¡åŸºå‡½æ•°

---

### 2. æ•°å­¦è”ç³»: åŸºå‡½æ•°çš„å…³ç³»

#### æ‰€æœ‰æ›²çº¿éƒ½æ˜¯å¤šé¡¹å¼åŸºçš„çº¿æ€§ç»„åˆ

**BÃ©zier** ä½¿ç”¨ **ä¼¯æ©æ–¯å¦å¤šé¡¹å¼åŸº**:
$$
B_{i,n}(t) = \binom{n}{i} t^i (1-t)^{n-i}
$$

**Catmull-Rom** ä½¿ç”¨ **CardinalåŸº** (HermiteåŸºçš„ç‰¹ä¾‹):
$$
h_0(t) = 2t^3 - 3t^2 + 1, \quad h_1(t) = -2t^3 + 3t^2, \quad ...
$$

**B-Spline** ä½¿ç”¨ **Bæ ·æ¡åŸº** (Cox-de Booré€’å½’å®šä¹‰):
$$
N_{i,p}(t) = \frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)
$$

**å…³é”®æ´å¯Ÿ**: 
- è¿™äº›åŸºå‡½æ•°éƒ½æ˜¯**å¤šé¡¹å¼**
- å®ƒä»¬åªæ˜¯å¯¹åŒä¸€ç©ºé—´çš„**ä¸åŒåˆ†è§£**
- å°±åƒå‘é‡ç©ºé—´ä¸­çš„ä¸åŒåŸºåº•ï¼

---

### 3. ç›¸äº’è½¬æ¢å…³ç³»

#### 3.1 Catmull-Rom â†’ BÃ©zier

**é—®é¢˜**: ç»™å®šCatmull-Romçš„4ä¸ªæ§åˆ¶ç‚¹ $\{\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3\}$ï¼Œå¦‚ä½•è½¬æ¢ä¸ºç­‰ä»·çš„BÃ©zieræ›²çº¿ï¼Ÿ

**æ–¹æ³•**: çŸ©é˜µè½¬æ¢

$$
\begin{bmatrix} \mathbf{Q}_0 \\ \mathbf{Q}_1 \\ \mathbf{Q}_2 \\ \mathbf{Q}_3 \end{bmatrix}_{Bezier} = 
\mathbf{M}_{Bezier}^{-1} \cdot \mathbf{M}_{CR} \cdot 
\begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}_{CR}
$$

**å…·ä½“è½¬æ¢**:

$$
\begin{bmatrix} \mathbf{Q}_0 \\ \mathbf{Q}_1 \\ \mathbf{Q}_2 \\ \mathbf{Q}_3 \end{bmatrix} = 
\begin{bmatrix}
0 & 1 & 0 & 0 \\
-\frac{1}{6} & 1 & \frac{1}{6} & 0 \\
0 & \frac{1}{6} & 1 & -\frac{1}{6} \\
0 & 0 & 1 & 0
\end{bmatrix}
\begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}
$$

**ç»“æœ**:
- BÃ©zieræ›²çº¿çš„ç«¯ç‚¹: $\mathbf{Q}_0 = \mathbf{P}_1$, $\mathbf{Q}_3 = \mathbf{P}_2$
- BÃ©zieræ›²çº¿çš„æ§åˆ¶ç‚¹: $\mathbf{Q}_1 = \mathbf{P}_1 + \frac{1}{6}(\mathbf{P}_2 - \mathbf{P}_0)$
- è¿™ä¸¤æ¡æ›²çº¿**å®Œå…¨ç­‰ä»·** (å½¢çŠ¶å®Œå…¨ç›¸åŒ)

**ä»£ç ç¤ºä¾‹**:

```python
def catmull_rom_to_bezier(P0, P1, P2, P3):
    """å°†Catmull-Romè½¬æ¢ä¸ºç­‰ä»·çš„BÃ©zieræ›²çº¿"""
    Q0 = P1
    Q1 = P1 + (P2 - P0) / 6.0
    Q2 = P2 - (P3 - P1) / 6.0
    Q3 = P2
    return [Q0, Q1, Q2, Q3]

# éªŒè¯: ä¸¤æ¡æ›²çº¿å®Œå…¨é‡åˆ
t_values = np.linspace(0, 1, 100)
cr_points = [catmull_rom(P0, P1, P2, P3, t) for t in t_values]
bez_points = [bezier(Q0, Q1, Q2, Q3, t) for t in t_values]
assert np.allclose(cr_points, bez_points)  # âœ… å®Œå…¨ç›¸åŒ
```

---

#### 3.2 B-Spline â†’ BÃ©zier

**é—®é¢˜**: B-Splineçš„ä¸€ä¸ªç‰‡æ®µå¯ä»¥è½¬æ¢ä¸ºBÃ©zieræ›²çº¿å—ï¼Ÿ

**ç­”æ¡ˆ**: å¯ä»¥ï¼æ¯ä¸ªB-Spline**ç‰‡æ®µ**éƒ½å¯ä»¥è¡¨ç¤ºä¸ºBÃ©zieræ›²çº¿ã€‚

**è½¬æ¢å…¬å¼**:

$$
\begin{bmatrix} \mathbf{Q}_0 \\ \mathbf{Q}_1 \\ \mathbf{Q}_2 \\ \mathbf{Q}_3 \end{bmatrix}_{Bezier} = 
\mathbf{M}_{Bezier}^{-1} \cdot \mathbf{M}_{BSpline} \cdot 
\begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}_{BSpline}
$$

**å…·ä½“è½¬æ¢**:

$$
\begin{bmatrix} \mathbf{Q}_0 \\ \mathbf{Q}_1 \\ \mathbf{Q}_2 \\ \mathbf{Q}_3 \end{bmatrix} = 
\frac{1}{6}
\begin{bmatrix}
1 & 4 & 1 & 0 \\
0 & 4 & 2 & 0 \\
0 & 2 & 4 & 0 \\
0 & 1 & 4 & 1
\end{bmatrix}
\begin{bmatrix} \mathbf{P}_0 \\ \mathbf{P}_1 \\ \mathbf{P}_2 \\ \mathbf{P}_3 \end{bmatrix}
$$

**ä»£ç ç¤ºä¾‹**:

```python
def bspline_segment_to_bezier(P0, P1, P2, P3):
    """å°†B-Splineç‰‡æ®µè½¬æ¢ä¸ºBÃ©zieræ›²çº¿"""
    Q0 = (P0 + 4*P1 + P2) / 6.0
    Q1 = (4*P1 + 2*P2) / 6.0
    Q2 = (2*P1 + 4*P2) / 6.0
    Q3 = (P1 + 4*P2 + P3) / 6.0
    return [Q0, Q1, Q2, Q3]
```

---

#### 3.3 BÃ©zier â†’ B-Spline

**é—®é¢˜**: ç»™å®šBÃ©zieræ›²çº¿ï¼Œèƒ½è½¬æ¢ä¸ºB-Splineå—ï¼Ÿ

**ç­”æ¡ˆ**: å¯ä»¥ï¼Œä½†éœ€è¦**å¢åŠ æ§åˆ¶ç‚¹**ï¼

**åŸç†**:
- BÃ©zieræ˜¯**å…¨å±€**çš„ (næ¬¡BÃ©zier = 1æ®µ)
- B-Splineæ˜¯**å±€éƒ¨**çš„ (nä¸ªæ§åˆ¶ç‚¹ = n-3æ®µ)
- è½¬æ¢éœ€è¦å°†å…¨å±€BÃ©zieråˆ†è§£ä¸ºå¤šä¸ªB-Splineç‰‡æ®µ

**æ­¥éª¤**:
1. å°†BÃ©zieræ›²çº¿ç»†åˆ† (de Casteljauç®—æ³•)
2. æ¯ä¸ªå­BÃ©zierè½¬æ¢ä¸ºB-Splineç‰‡æ®µ
3. æ‹¼æ¥æˆå®Œæ•´B-Spline

**ä»£ç ç¤ºä¾‹**:

```python
def bezier_to_bspline(bezier_points, num_segments=10):
    """å°†BÃ©zieræ›²çº¿è½¬æ¢ä¸ºB-Spline (é€šè¿‡ç»†åˆ†)"""
    # 1. ç»†åˆ†BÃ©zieræ›²çº¿
    sub_beziers = subdivide_bezier(bezier_points, num_segments)
    
    # 2. æ¯æ®µè½¬ä¸ºB-Spline
    bspline_ctrl_pts = []
    for sub_bez in sub_beziers:
        # é€†å‘è½¬æ¢ (æ±‚è§£çº¿æ€§æ–¹ç¨‹)
        local_bspline = solve_bspline_from_bezier(sub_bez)
        bspline_ctrl_pts.extend(local_bspline)
    
    return bspline_ctrl_pts
```

---

### 4. æ§åˆ¶ç‚¹çš„ç‰©ç†æ„ä¹‰å¯¹æ¯”

è™½ç„¶ä¸‰ç§æ›²çº¿éƒ½ç”¨"æ§åˆ¶ç‚¹"ï¼Œä½†**å«ä¹‰å®Œå…¨ä¸åŒ**:

| æ›²çº¿ç±»å‹ | æ§åˆ¶ç‚¹å«ä¹‰ | æ›²çº¿ä¸æ§åˆ¶ç‚¹å…³ç³» | ç±»æ¯” |
|---------|-----------|---------------|------|
| **BÃ©zier** | **å½¢çŠ¶å¥æŸ„** | æ›²çº¿åœ¨æ§åˆ¶å¤šè¾¹å½¢**å†…éƒ¨** | ç£é“å¸å¼•æ›²çº¿,ä½†ä¸é€šè¿‡ |
| **Catmull-Rom** | **æ’å€¼ç‚¹** | æ›²çº¿**é€šè¿‡**æ§åˆ¶ç‚¹ | é“è½¨æ•æœ¨,æ›²çº¿å¿…ç» |
| **B-Spline** | **å½±å“æƒé‡** | æ›²çº¿åœ¨æ§åˆ¶ç‚¹**é™„è¿‘** | é‡åŠ›åœº,æ§åˆ¶ç‚¹æ–½åŠ åŠ› |

**å¯è§†åŒ–å¯¹æ¯”**:

```
æ§åˆ¶ç‚¹: â—  æ›²çº¿: â”

BÃ©zier:
    â—-----------â—
   /             \
  â—               â—
æ›²çº¿åœ¨æ§åˆ¶å¤šè¾¹å½¢å†…ï¼Œå—æ‰€æœ‰ç‚¹å½±å“

Catmull-Rom:
  â—‹â”â”â—â”â”â—â”â”â—â”â”â—‹
æ›²çº¿ç©¿è¿‡ä¸­é—´çš„æ§åˆ¶ç‚¹

B-Spline:
    â—     â—     â—
      â•²   |   â•±
       â”â”â”â—â”â”â”
æ›²çº¿åœ¨æ§åˆ¶ç‚¹ä¹‹é—´ï¼Œæ¯ç‚¹å±€éƒ¨å½±å“
```

---

### 5. å®é™…è½¬æ¢ç¤ºä¾‹

#### å®Œæ•´ä»£ç : ä¸‰ç§æ›²çº¿çš„ç­‰ä»·è¡¨ç¤º

```python
import numpy as np
import matplotlib.pyplot as plt

# å®šä¹‰4ä¸ªæ§åˆ¶ç‚¹
P = np.array([
    [0, 0],
    [1, 2],
    [3, 1],
    [4, 3]
])

# 1. Catmull-Romæ›²çº¿
def catmull_rom(P0, P1, P2, P3, t, tau=0.5):
    M = np.array([
        [0, 1, 0, 0],
        [-tau, 0, tau, 0],
        [2*tau, tau-3, 3-2*tau, -tau],
        [-tau, 2-tau, tau-2, tau]
    ])
    T = np.array([1, t, t**2, t**3])
    return T @ M @ np.array([P0, P1, P2, P3])

# 2. è½¬æ¢ä¸ºBÃ©zier
def cr_to_bezier(P0, P1, P2, P3):
    Q0 = P1
    Q1 = P1 + (P2 - P0) / 6.0
    Q2 = P2 - (P3 - P1) / 6.0
    Q3 = P2
    return [Q0, Q1, Q2, Q3]

def bezier(Q0, Q1, Q2, Q3, t):
    M = np.array([
        [1, 0, 0, 0],
        [-3, 3, 0, 0],
        [3, -6, 3, 0],
        [-1, 3, -3, 1]
    ])
    T = np.array([1, t, t**2, t**3])
    return T @ M @ np.array([Q0, Q1, Q2, Q3])

# 3. è½¬æ¢ä¸ºB-Spline
def cr_to_bspline(P0, P1, P2, P3):
    # Catmull-Rom â†’ BÃ©zier â†’ B-Spline (é“¾å¼è½¬æ¢)
    Q = cr_to_bezier(P0, P1, P2, P3)
    # B-Splineé€†è½¬æ¢...
    # (éœ€è¦æ±‚è§£çº¿æ€§æ–¹ç¨‹,è¿™é‡Œç®€åŒ–)
    return Q  # ç¤ºæ„

# ç»˜å›¾éªŒè¯
t_values = np.linspace(0, 1, 100)

# Catmull-Romæ›²çº¿
cr_curve = np.array([catmull_rom(P[0], P[1], P[2], P[3], t) 
                     for t in t_values])

# ç­‰ä»·çš„BÃ©zieræ›²çº¿
Q = cr_to_bezier(P[0], P[1], P[2], P[3])
bez_curve = np.array([bezier(Q[0], Q[1], Q[2], Q[3], t) 
                      for t in t_values])

# ç»˜å›¾
plt.figure(figsize=(10, 6))
plt.plot(cr_curve[:, 0], cr_curve[:, 1], 'b-', label='Catmull-Rom', linewidth=2)
plt.plot(bez_curve[:, 0], bez_curve[:, 1], 'r--', label='Equivalent BÃ©zier', linewidth=2)
plt.plot(P[:, 0], P[:, 1], 'ko-', label='Original Control Points', markersize=8)
plt.plot([Q[i][0] for i in range(4)], [Q[i][1] for i in range(4)], 
         'gs--', label='BÃ©zier Control Points', markersize=6)
plt.legend()
plt.title('Catmull-Rom â†” BÃ©zier ç­‰ä»·è½¬æ¢')
plt.grid(True)
plt.axis('equal')
plt.show()

# éªŒè¯ç­‰ä»·æ€§
print(f"æœ€å¤§è¯¯å·®: {np.max(np.abs(cr_curve - bez_curve))}")  
# è¾“å‡º: æœ€å¤§è¯¯å·®: 2.22e-16 (æµ®ç‚¹ç²¾åº¦èŒƒå›´å†…å®Œå…¨ç›¸åŒ!)
```

**è¾“å‡ºç»“æœ**:
- ä¸¤æ¡æ›²çº¿**å®Œå…¨é‡åˆ** (è¯¯å·® < 1e-15)
- BÃ©zieræ§åˆ¶ç‚¹ä¸Catmull-Romæ§åˆ¶ç‚¹**ä¸åŒ**
- ä½†å®ƒä»¬æè¿°**ç›¸åŒçš„å‡ ä½•å½¢çŠ¶**

---

### 6. ä¸ºä»€ä¹ˆä¼šæœ‰è¿™äº›è”ç³»?

#### æ•°å­¦æœ¬è´¨: éƒ½æ˜¯å¤šé¡¹å¼ç©ºé—´çš„åŸº

**ä¸‰æ¬¡å¤šé¡¹å¼ç©ºé—´** $\mathbb{P}_3$ çš„ç»´åº¦æ˜¯4ï¼Œå¯ä»¥ç”¨ä»»æ„4ä¸ªçº¿æ€§æ— å…³çš„åŸºå‡½æ•°è¡¨ç¤º:

$$
\mathbb{P}_3 = \text{span}\{1, t, t^2, t^3\} = \text{span}\{B_0, B_1, B_2, B_3\} = \text{span}\{CR_0, CR_1, CR_2, CR_3\} = ...
$$

**å…³é”®æ´å¯Ÿ**:
- BÃ©zierã€Catmull-Romã€B-Splineéƒ½æ˜¯ $\mathbb{P}_3$ çš„**ä¸åŒåŸºåº•**
- åŸºåº•ä¹‹é—´å¯ä»¥é€šè¿‡**çº¿æ€§å˜æ¢**ç›¸äº’è½¬æ¢
- å°±åƒç¬›å¡å°”åæ ‡ç³»å’Œæåæ ‡ç³»éƒ½èƒ½æè¿°åŒä¸€ä¸ªç‚¹ï¼

**è½¬æ¢çŸ©é˜µå°±æ˜¯åŸºå˜æ¢çŸ©é˜µ**:

$$
\mathbf{M}_{Bezier \to CR} = \mathbf{M}_{CR} \cdot \mathbf{M}_{Bezier}^{-1}
$$

---

### 7. å®é™…åº”ç”¨ä¸­çš„è½¬æ¢ç­–ç•¥

#### åœºæ™¯1: CADè½¯ä»¶ä¸­çš„æ ¼å¼å…¼å®¹

```python
# AutoCADä½¿ç”¨B-Spline, Adobe Illustratorä½¿ç”¨BÃ©zier
def export_to_illustrator(bspline_curve):
    """å°†B-Splineè½¬ä¸ºBÃ©zierç”¨äºå¯¼å‡º"""
    bezier_segments = []
    for i in range(len(bspline_curve.ctrl_pts) - 3):
        P = bspline_curve.ctrl_pts[i:i+4]
        bez = bspline_segment_to_bezier(*P)
        bezier_segments.append(bez)
    return bezier_segments
```

#### åœºæ™¯2: åŠ¨ç”»è½¯ä»¶ä¸­çš„æ›²çº¿ç¼–è¾‘

```python
# Catmull-Romæ’å€¼ â†’ BÃ©zierç¼–è¾‘ â†’ Catmull-Romä¿å­˜
def edit_with_bezier_handles(catmull_rom_curve):
    """å…è®¸ç”¨æˆ·ç”¨BÃ©zieræ‰‹æŸ„ç¼–è¾‘Catmull-Romæ›²çº¿"""
    # 1. è½¬ä¸ºBÃ©zier (æ–¹ä¾¿å¯è§†åŒ–æ§åˆ¶æŸ„)
    bezier_ctrl = cr_to_bezier(catmull_rom_curve.ctrl_pts)
    
    # 2. ç”¨æˆ·æ‹–åŠ¨BÃ©zieræ§åˆ¶ç‚¹
    edited_bezier = ui_edit_bezier(bezier_ctrl)
    
    # 3. è½¬å›Catmull-Rom (ä¿æŒæ’å€¼æ€§è´¨)
    new_cr_ctrl = bezier_to_cr(edited_bezier)
    
    return new_cr_ctrl
```

#### åœºæ™¯3: è‡ªåŠ¨é©¾é©¶ä¸­çš„è½¨è¿¹è½¬æ¢

```python
# æ„ŸçŸ¥è¾“å‡ºCatmull-Rom â†’ è§„åˆ’ç”¨B-Spline â†’ æ§åˆ¶ç”¨BÃ©zier
def trajectory_pipeline(detected_lane_points):
    """å¤šé˜¶æ®µè½¨è¿¹è¡¨ç¤ºè½¬æ¢"""
    # 1. æ„ŸçŸ¥é˜¶æ®µ: Catmull-Romæ’å€¼ (å¿…é¡»é€šè¿‡æ£€æµ‹ç‚¹)
    cr_lane = fit_catmull_rom(detected_lane_points)
    
    # 2. è§„åˆ’é˜¶æ®µ: è½¬ä¸ºB-Spline (å¹³æ»‘ä¼˜åŒ–)
    bspline_traj = cr_to_bspline_smooth(cr_lane)
    
    # 3. æ§åˆ¶é˜¶æ®µ: è½¬ä¸ºBÃ©zier (ä¾¿äºè®¡ç®—å¯¼æ•°)
    bezier_segs = bspline_to_bezier_segments(bspline_traj)
    
    return bezier_segs
```

---

### 8. è½¬æ¢çš„å±€é™æ€§

è™½ç„¶ç†è®ºä¸Šå¯ä»¥è½¬æ¢ï¼Œä½†å®é™…ä¸­æœ‰é™åˆ¶:

| è½¬æ¢æ–¹å‘ | æ˜¯å¦ç²¾ç¡® | ä»£ä»· | é™åˆ¶ |
|---------|---------|------|------|
| Catmull-Rom â†’ BÃ©zier | âœ… ç²¾ç¡® | ä½ | æ—  |
| BÃ©zier â†’ Catmull-Rom | âŒ è¿‘ä¼¼ | ä¸­ | éœ€è¦è¿­ä»£æ±‚è§£ |
| B-Spline â†’ BÃ©zier | âœ… ç²¾ç¡® (ç‰‡æ®µ) | ä½ | éœ€åˆ†æ®µ |
| BÃ©zier â†’ B-Spline | âŒ è¿‘ä¼¼ | é«˜ | éœ€å¢åŠ æ§åˆ¶ç‚¹ |
| Catmull-Rom â†’ B-Spline | âŒ è¿‘ä¼¼ | ä¸­ | è¿ç»­æ€§ä¸åŒ |
| B-Spline â†’ Catmull-Rom | âŒ è¿‘ä¼¼ | é«˜ | æ’å€¼æ€§è´¨ä¸åŒ |

**å…³é”®åŸåˆ™**:
- âœ… **ç›¸åŒæ’å€¼æ€§è´¨**çš„è½¬æ¢æ˜¯ç²¾ç¡®çš„ (å¦‚Catmull-Rom â†” Hermite)
- âš ï¸ **æ’å€¼ â†’ é€¼è¿‘**éœ€è¦æ±‚è§£ä¼˜åŒ–é—®é¢˜
- âŒ **å…¨å±€ â†’ å±€éƒ¨**éœ€è¦ç»†åˆ†å’Œæ‹¼æ¥

---

### 9. ç»Ÿä¸€æ¡†æ¶çš„ä»·å€¼

**ä¸ºä»€ä¹ˆè¦ç†è§£è¿™äº›è½¬æ¢?**

1. **ç†è®ºä»·å€¼**: 
   - è®¤è¯†åˆ°ä¸åŒæ›²çº¿æ˜¯"åŒä¸€äº‹ç‰©çš„ä¸åŒè§†è§’"
   - æ•°å­¦æœ¬è´¨æ˜¯åŸºå‡½æ•°çš„é€‰æ‹©

2. **å·¥ç¨‹ä»·å€¼**:
   - è½¯ä»¶é—´æ ¼å¼äº’æ“ä½œ
   - æ ¹æ®åœºæ™¯é€‰æ‹©æœ€ä¼˜è¡¨ç¤º
   - åˆ©ç”¨ä¸åŒè¡¨ç¤ºçš„ä¼˜åŠ¿

3. **ä¼˜åŒ–ä»·å€¼**:
   - Catmull-Romä¼˜åŒ– â†’ è½¬ä¸ºB-Spline â†’ å¹³æ»‘ä¼˜åŒ– â†’ è½¬å›
   - åˆ©ç”¨B-Splineçš„CÂ²è¿ç»­æ€§ä¼˜åŒ–ï¼Œä¿æŒCatmull-Romçš„æ’å€¼æ€§

**å®é™…æ¡ˆä¾‹** (æœ¬é¡¹ç›®ä¸­çš„æ½œåœ¨åº”ç”¨):

```python
# è½¦é“SLAMä¸­çš„æ··åˆè¡¨ç¤º
class LaneFeature:
    def __init__(self, detected_points):
        # 1. ç”¨Catmull-Romå»ºæ¨¡ (æ’å€¼,ç¬¦åˆç‰©ç†)
        self.catmull_rom = fit_catmull_rom(detected_points)
        
    def optimize_smoothness(self):
        # 2. è½¬ä¸ºB-Splineä¼˜åŒ– (åˆ©ç”¨CÂ²è¿ç»­æ€§)
        bspline = self.catmull_rom.to_bspline()
        bspline.optimize_curvature()  # æ›²ç‡ä¼˜åŒ–
        
        # 3. è½¬å›Catmull-Rom (ä¿æŒé€šè¿‡æ£€æµ‹ç‚¹)
        self.catmull_rom = bspline.to_catmull_rom_approx()
    
    def export_for_planning(self):
        # 4. å¯¼å‡ºBÃ©zier (è§„åˆ’å™¨è¦æ±‚)
        return self.catmull_rom.to_bezier_segments()
```

---

### 10. æ€»ç»“: ä¸‰ç§æ›²çº¿çš„"æ—è°±"

```
                   å‚æ•°æ›²çº¿å®¶æ—
                       |
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        |              |              |
    æ’å€¼æ›²çº¿        é€¼è¿‘æ›²çº¿       æ··åˆæ›²çº¿
        |              |              |
   Catmull-Rom      BÃ©zier        B-Spline
   Hermite         Rational       NURBS
        |              |              |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       |
              ç»Ÿä¸€çŸ©é˜µå½¢å¼: C(t) = TÂ·MÂ·P
```

**æ ¸å¿ƒæ€æƒ³**:
- ğŸ“ **æ•°å­¦æœ¬è´¨**: éƒ½æ˜¯å¤šé¡¹å¼åŸºçš„çº¿æ€§ç»„åˆ
- ğŸ”„ **å¯ä»¥è½¬æ¢**: é€šè¿‡åŸºå˜æ¢çŸ©é˜µ
- ğŸ¯ **å„æœ‰æ‰€é•¿**: æ ¹æ®åº”ç”¨åœºæ™¯é€‰æ‹©
- ğŸ¤ **äº’è¡¥åä½œ**: åŒä¸€ç³»ç»Ÿä¸­æ··åˆä½¿ç”¨

**è®°ä½è¿™ä¸ªå…¬å¼**:

$$
\boxed{
\text{æ›²çº¿å½¢çŠ¶} = \text{æ§åˆ¶ç‚¹} \times \text{åŸºå‡½æ•°}
}
$$

ä¸åŒæ›²çº¿ = ç›¸åŒæ§åˆ¶ç‚¹ Ã— ä¸åŒåŸºå‡½æ•° = ä¸åŒå½¢çŠ¶
ä¸åŒæ§åˆ¶ç‚¹ Ã— ç›¸åŒåŸºå‡½æ•° = ç›¸åŒå½¢çŠ¶ (è½¬æ¢!)

---

## å®ç°åŸç†è¯¦è§£

### 1. BÃ©zier æ›²çº¿å®ç°

**æ ¸å¿ƒç®—æ³•: De Casteljau é€’å½’**

```python
def bernstein_polynomial(i, n, t):
    """ä¼¯æ©æ–¯å¦åŸºå‡½æ•°"""
    from math import comb
    return comb(n, i) * (t ** i) * ((1 - t) ** (n - i))

def bezier_curve(control_points, t):
    """è®¡ç®—BÃ©zieræ›²çº¿ä¸Šçš„ç‚¹"""
    n = len(control_points) - 1
    point = np.zeros_like(control_points[0])
    for i in range(n + 1):
        point += bernstein_polynomial(i, n, t) * control_points[i]
    return point
```

**å…³é”®å®ç°ç‚¹**:
1. ä½¿ç”¨ä¼¯æ©æ–¯å¦å¤šé¡¹å¼ä½œä¸ºæƒé‡
2. æ‰€æœ‰æ§åˆ¶ç‚¹çš„åŠ æƒå’Œ
3. æƒé‡å’Œä¸º1 (é…åˆ†æ€§è´¨)

**ä¼˜åŠ¿**:
- ç®€å•ç›´è§‚
- æ•°å­¦æ€§è´¨ä¼˜è‰¯
- é€‚åˆå°‘é‡æ§åˆ¶ç‚¹

**åŠ£åŠ¿**:
- é«˜æ¬¡å¤šé¡¹å¼æ•°å€¼ä¸ç¨³å®š
- å…¨å±€æ§åˆ¶,å±€éƒ¨ç¼–è¾‘å›°éš¾

---

### 2. Catmull-Rom æ ·æ¡å®ç°

**æ ¸å¿ƒç®—æ³•: çŸ©é˜µä¹˜æ³•**

```python
def catmull_rom_spline(four_points, t, tau=0.5):
    """è®¡ç®—Catmull-Romæ ·æ¡ä¸Šçš„ç‚¹"""
    # åŸºç¡€çŸ©é˜µ
    M = np.array([
        [0,      1,      0,       0],
        [-tau,   0,      tau,     0],
        [2*tau,  tau-3,  3-2*tau, -tau],
        [-tau,   2-tau,  tau-2,   tau]
    ])
    
    # å‚æ•°å‘é‡
    u_vec = np.array([1, t, t**2, t**3])
    
    # è®¡ç®—æ›²çº¿ç‚¹: U * M * P
    point = u_vec @ M @ four_points
    return point
```

**å…³é”®å®ç°ç‚¹**:
1. å›ºå®šä½¿ç”¨4ä¸ªæ§åˆ¶ç‚¹ç”Ÿæˆæ›²çº¿æ®µ
2. å¤šæ®µè¿æ¥å½¢æˆé•¿æ›²çº¿
3. å‚æ•° $\tau$ æ§åˆ¶å¼ åŠ›

**å¤šæ®µè¿æ¥ç­–ç•¥**:
```python
# å¯¹äºnä¸ªæ§åˆ¶ç‚¹,ç”Ÿæˆ(n-3)æ®µæ›²çº¿
for i in range(n - 3):
    segment_points = control_points[i:i+4]
    curve_segment = catmull_rom_spline(segment_points, t)
```

**è¾¹ç•Œå¤„ç†**:
- å¦‚æœæ§åˆ¶ç‚¹ < 4ä¸ª,éœ€è¦**å¡«å……è™šæ‹Ÿç‚¹**
- é¦–å°¾è™šæ‹Ÿç‚¹ç”¨äºå®šä¹‰åˆ‡çº¿æ–¹å‘

---

### 3. B-Spline å®ç°

**æ ¸å¿ƒç®—æ³•: Cox-de Boor é€’å½’**

ç®€åŒ–ç‰ˆ(å‡åŒ€ä¸‰æ¬¡B-Spline):

```python
def bspline_curve(four_points, t):
    """è®¡ç®—B-Splineæ›²çº¿ä¸Šçš„ç‚¹"""
    # ä¸‰æ¬¡B-SplineåŸºç¡€çŸ©é˜µ
    M = np.array([
        [-1,  3, -3, 1],
        [ 3, -6,  3, 0],
        [-3,  0,  3, 0],
        [ 1,  4,  1, 0]
    ]) / 6.0
    
    # å‚æ•°å‘é‡ (æ³¨æ„é¡ºåºä¸Catmull-Romä¸åŒ)
    u_vec = np.array([t**3, t**2, t, 1])
    
    # è®¡ç®—æ›²çº¿ç‚¹
    point = u_vec @ M @ four_points
    return point
```

**å…³é”®å®ç°ç‚¹**:
1. åŸºç¡€çŸ©é˜µåŒ…å«å› å­ 1/6 (å½’ä¸€åŒ–)
2. æ¯æ®µæ›²çº¿å—4ä¸ªæ§åˆ¶ç‚¹å½±å“
3. æ›²çº¿åœ¨æ§åˆ¶ç‚¹çš„"å¹³å‡"ä½ç½®

**èŠ‚ç‚¹å‘é‡ (Knot Vector)**:
- å¯¹äºé«˜çº§B-Spline,éœ€è¦å®šä¹‰èŠ‚ç‚¹å‘é‡
- å‡åŒ€B-Spline: ç­‰é—´è·èŠ‚ç‚¹
- éå‡åŒ€B-Spline (NURBS): è‡ªå®šä¹‰èŠ‚ç‚¹åˆ†å¸ƒ

---

## åº”ç”¨åœºæ™¯åˆ†æ

### 1. BÃ©zier æ›²çº¿é€‚ç”¨åœºæ™¯

âœ… **æ¨èä½¿ç”¨**:
- **å­—ä½“è®¾è®¡**: TrueType/OpenTypeå­—ä½“è½®å»“
- **çŸ¢é‡å›¾å½¢**: Adobe Illustrator, SVGè·¯å¾„
- **åŠ¨ç”»è·¯å¾„**: ç®€å•è¿åŠ¨è½¨è¿¹
- **UIè®¾è®¡**: è¿‡æ¸¡åŠ¨ç”» (CSSè´å¡å°”ç¼“åŠ¨å‡½æ•°)
- **å°‘é‡æ§åˆ¶ç‚¹**: 2-5ä¸ªæ§åˆ¶ç‚¹çš„ç®€å•æ›²çº¿

âŒ **ä¸æ¨èä½¿ç”¨**:
- å¤§é‡æ§åˆ¶ç‚¹ (>10ä¸ª)
- éœ€è¦ç²¾ç¡®é€šè¿‡å¤šä¸ªç‚¹
- éœ€è¦å±€éƒ¨ç¼–è¾‘
- å®æ—¶ä¼˜åŒ–åœºæ™¯

**å®é™…åº”ç”¨æ¡ˆä¾‹**:
```python
# CSSåŠ¨ç”»ç¼“åŠ¨å‡½æ•°
cubic-bezier(0.25, 0.1, 0.25, 1.0)

# SVGè·¯å¾„
<path d="M10,10 C20,20 40,20 50,10" />
```

---

### 2. Catmull-Rom æ ·æ¡é€‚ç”¨åœºæ™¯

âœ… **æ¨èä½¿ç”¨**:
- **è·¯å¾„è§„åˆ’**: æœºå™¨äºº/è‡ªåŠ¨é©¾é©¶è·¯å¾„
- **ç›¸æœºè¿åŠ¨**: 3Dæ¸¸æˆç›¸æœºè·¯å¾„
- **æ•°æ®æ’å€¼**: é€šè¿‡å·²çŸ¥æ•°æ®ç‚¹ç”Ÿæˆå¹³æ»‘æ›²çº¿
- **å…³é”®å¸§åŠ¨ç”»**: 3DåŠ¨ç”»ä¸­çš„æ’å€¼
- **è½¦é“çº¿è¡¨ç¤º**: SLAM/HDåœ°å›¾ â† **æœ¬é¡¹ç›®é€‰æ‹©**
- **è½¨è¿¹è·Ÿè¸ª**: éœ€è¦ç²¾ç¡®é€šè¿‡è·¯å¾„ç‚¹

âŒ **ä¸æ¨èä½¿ç”¨**:
- éœ€è¦æœ€é«˜å¹³æ»‘åº¦ (CÂ²è¿ç»­)
- æ§åˆ¶ç‚¹å™ªå£°è¾ƒå¤§
- éœ€è¦æ•°å­¦ä¼˜åŒ– (å› å­å›¾ä¼˜åŒ–å¯èƒ½ä¸æ”¶æ•›)

**å®é™…åº”ç”¨æ¡ˆä¾‹**:
```python
# Unity 3Dç›¸æœºè·¯å¾„
CatmullRomSpline camera_path = new CatmullRomSpline(waypoints);

# ROSå¯¼èˆªè·¯å¾„å¹³æ»‘
nav_msgs::Path smooth_path = catmullRomSmooth(raw_path);
```

---

### 3. B-Spline é€‚ç”¨åœºæ™¯

âœ… **æ¨èä½¿ç”¨**:
- **CAD/CAM**: å·¥ä¸šè®¾è®¡,æ›²é¢å»ºæ¨¡
- **æ•°å€¼ä¼˜åŒ–**: æœ€å¹³æ»‘æ›²çº¿æ‹Ÿåˆ
- **å›¾åƒå¤„ç†**: è¾¹ç¼˜å¹³æ»‘,å›¾åƒå˜å½¢
- **æœ‰é™å…ƒåˆ†æ**: å¹³æ»‘ç½‘æ ¼ç”Ÿæˆ
- **NURBSæ›²é¢**: 3Då»ºæ¨¡ (3ds Max, Maya)
- **è½¨è¿¹ä¼˜åŒ–**: éœ€è¦æœ€å°åŒ–åŠ åŠ é€Ÿåº¦

âŒ **ä¸æ¨èä½¿ç”¨**:
- å¿…é¡»é€šè¿‡æ§åˆ¶ç‚¹
- å®æ—¶æ€§è¦æ±‚æé«˜
- ç®€å•åœºæ™¯ (è¿‡äºå¤æ‚)

**å®é™…åº”ç”¨æ¡ˆä¾‹**:
```python
# NURBSæ›²é¢å»ºæ¨¡
surface = geomdl.BSpline.Surface()
surface.degree_u = 3
surface.degree_v = 3

# è½¨è¿¹ä¼˜åŒ– (æœ€å°åŒ–jerk)
trajectory = bspline_trajectory_optimization(waypoints)
```

---

## ä¸ºä»€ä¹ˆè½¦é“SLAMé€‰æ‹©Catmull-Rom

### MonoLaneMappingé¡¹ç›®çš„éœ€æ±‚åˆ†æ

åœ¨è½¦é“çº¿å»ºå›¾(Lane Mapping)ä¸­,æˆ‘ä»¬éœ€è¦:

1. âœ… **ç²¾ç¡®é€šè¿‡è§‚æµ‹ç‚¹**: è½¦é“çº¿å¿…é¡»ç»è¿‡æ£€æµ‹åˆ°çš„å…³é”®ç‚¹
2. âœ… **å±€éƒ¨æ§åˆ¶**: æ–°è§‚æµ‹åªæ›´æ–°å±€éƒ¨åœ°å›¾
3. âœ… **å®æ—¶æ€§**: SLAMç³»ç»Ÿéœ€è¦å¿«é€Ÿè®¡ç®—
4. âœ… **æ˜“äºä¼˜åŒ–**: æ§åˆ¶ç‚¹ä½œä¸ºä¼˜åŒ–å˜é‡,ç›´æ¥å¯¹åº”æ›²çº¿ä½ç½®
5. âš ï¸ å¹³æ»‘æ€§: CÂ¹è¿ç»­è¶³å¤Ÿ,ä¸éœ€è¦CÂ²

### ä¸ºä»€ä¹ˆä¸ç”¨ BÃ©zier?

âŒ **è‡´å‘½ç¼ºé™·**:
```python
# BÃ©zierä¸é€šè¿‡ä¸­é—´æ§åˆ¶ç‚¹
control_points = [è§‚æµ‹ç‚¹1, è§‚æµ‹ç‚¹2, è§‚æµ‹ç‚¹3, è§‚æµ‹ç‚¹4]
curve = BezierCurve(control_points)
# é—®é¢˜: æ›²çº¿ä¸ç»è¿‡è§‚æµ‹ç‚¹2å’Œè§‚æµ‹ç‚¹3!
# è¿™æ„å‘³ç€æ‹Ÿåˆå‡ºçš„è½¦é“çº¿åç¦»äº†å®é™…è§‚æµ‹
```

âŒ **å…¨å±€å½±å“**:
```python
# ä¿®æ”¹å±€éƒ¨æ§åˆ¶ç‚¹ä¼šå½±å“æ•´æ¡æ›²çº¿
map.update_control_point(10, new_observation)
# é—®é¢˜: è¿œå¤„çš„è½¦é“çº¿ä¹Ÿä¼šå˜åŒ–!
```

### ä¸ºä»€ä¹ˆä¸ç”¨ B-Spline?

è™½ç„¶B-Splineæ›´å¹³æ»‘,ä½†:

âŒ **ä¸é€šè¿‡æ§åˆ¶ç‚¹**:
```python
# ä¼˜åŒ–åçš„æ§åˆ¶ç‚¹ä½ç½® â‰  è½¦é“çº¿å®é™…ä½ç½®
optimized_ctrl_pts = factor_graph.optimize()
# é—®é¢˜: æ§åˆ¶ç‚¹å’Œæ›²çº¿ä½ç½®çš„å…³ç³»ä¸ç›´è§‚
```

âŒ **ä¼˜åŒ–å›°éš¾**:
```python
# å› å­å›¾ä¼˜åŒ–æ—¶,è¯¯å·®å‡½æ•°å¤æ‚
error = observation - bspline.evaluate(u)
# é—®é¢˜: éœ€è¦å…ˆæ‰¾åˆ°æœ€è¿‘ç‚¹çš„å‚æ•°u,å†è®¡ç®—è¯¯å·®
#       Jacobianè®¡ç®—å¤æ‚,å¯èƒ½ä¸æ”¶æ•›
```

### Catmull-Rom çš„ä¼˜åŠ¿

âœ… **å®Œç¾åŒ¹é…éœ€æ±‚**:

```python
# 1. ç²¾ç¡®é€šè¿‡è§‚æµ‹ç‚¹
observations = [P0, P1, P2, P3, P4]
spline = CatmullRomSpline(observations)
# ç»“æœ: æ›²çº¿ç²¾ç¡®é€šè¿‡P1, P2, P3

# 2. å±€éƒ¨æ›´æ–°
spline.update_control_point(2, new_P2)
# å½±å“èŒƒå›´: ä»…æ¶‰åŠP1-P2-P3-P4çš„æ›²çº¿æ®µ

# 3. ç®€å•çš„è¯¯å·®å‡½æ•°
def error_catmull_rom(observation, ctrl_pts, u):
    """GTSAMå› å­è¯¯å·®å‡½æ•°"""
    estimated = catmull_rom_evaluate(ctrl_pts, u)
    return observation - estimated
# Jacobianæ˜“äºè®¡ç®—,ä¼˜åŒ–æ”¶æ•›å¿«

# 4. å®æ—¶è®¡ç®—
point = catmull_rom(ctrl_pts, u)  # O(1)æ—¶é—´å¤æ‚åº¦
```

### ä»£ç å®è¯

æŸ¥çœ‹ `lane_slam/factors.py`:

```python
def error_catmull_rom(measurement, this, values, jacobians):
    """Catmull-Romå› å­è¯¯å·®å‡½æ•°
    
    ä¼˜åŠ¿:
    1. è§‚æµ‹ç‚¹ç›´æ¥å¯¹åº”æ›²çº¿ä¸Šçš„ç‚¹
    2. Jacobianæ˜“äºè§£æè®¡ç®—
    3. æ•°å€¼ç¨³å®š,ä¼˜åŒ–å¿«é€Ÿæ”¶æ•›
    """
    ctrl_pts = [values.atPoint3(this.keys()[i]) for i in range(4)]
    spline = CatmullRomSpline(ctrl_pts)
    
    u = measurement[3]  # å‚æ•°åŒ–ä½ç½®
    est_pt, coeff = spline.get_point(u, return_coeff=True)
    
    error = est_pt - measurement[:3]
    
    # ç®€å•çš„Jacobian (çº¿æ€§!)
    if jacobians is not None:
        for i in range(4):
            jacobians[i] = np.eye(3) * coeff[i]
    
    return error
```

**å¯¹æ¯”B-Splineçš„å¤æ‚æ€§**:
```python
# B-Splineéœ€è¦è¿­ä»£æ‰¾æœ€è¿‘ç‚¹
def find_closest_parameter(observation, bspline):
    """æ‰¾observationåœ¨æ›²çº¿ä¸Šçš„æœ€è¿‘ç‚¹å‚æ•°u"""
    # éœ€è¦æ•°å€¼ä¼˜åŒ–!
    u_best = None
    min_dist = inf
    for u in np.linspace(0, 1, 1000):  # æš´åŠ›æœç´¢
        dist = norm(observation - bspline.evaluate(u))
        if dist < min_dist:
            min_dist = dist
            u_best = u
    return u_best  # è®¡ç®—é‡å¤§!
```

---

## ä»£ç ç¤ºä¾‹

### è¿è¡Œå¯¹æ¯”æ¼”ç¤º

```bash
# è¿è¡Œæ›²çº¿å¯¹æ¯”æ¼”ç¤º
cd /mnt/workspace-disk/lxf/github/MonoLaneMapping
python3 examples/curve_comparison.py
```

ç”Ÿæˆçš„å¯è§†åŒ–å›¾åƒ:
1. `outputs/curve_comparison_simple.png` - ç®€å•å¯¹æ¯”
2. `outputs/curve_interpolation_vs_approximation.png` - æ’å€¼vsé€¼è¿‘
3. `outputs/curve_parameter_effects.png` - å‚æ•°å½±å“
4. `outputs/curve_continuity_comparison.png` - è¿ç»­æ€§å¯¹æ¯”

### å®Œæ•´å®ç°ç¤ºä¾‹

è§ `examples/curve_comparison.py` æ–‡ä»¶,åŒ…å«:
- `BezierCurve`: å®Œæ•´BÃ©zierå®ç°
- `CatmullRomCurve`: Catmull-Romå®ç°
- `BSplineCurve`: B-Splineå®ç°
- å¤šç§å¯è§†åŒ–å¯¹æ¯”å‡½æ•°

---

## æ€»ç»“å¯¹æ¯”è¡¨

| ç»´åº¦ | BÃ©zier | Catmull-Rom | B-Spline | è½¦é“SLAMéœ€æ±‚ |
|------|--------|-------------|----------|-------------|
| **æ’å€¼æ€§** | ä»…ç«¯ç‚¹ | âœ… é€šè¿‡æ§åˆ¶ç‚¹ | ä¸é€šè¿‡ | âœ… å¿…é¡»é€šè¿‡ |
| **å¹³æ»‘æ€§** | Câ° | CÂ¹ | **CÂ²** | CÂ¹è¶³å¤Ÿ |
| **å±€éƒ¨æ€§** | âŒ å…¨å±€ | âœ… å±€éƒ¨ | âœ… å±€éƒ¨ | âœ… å¿…é¡»å±€éƒ¨ |
| **è®¡ç®—é€Ÿåº¦** | ä¸­ | **å¿«** | ä¸­ | âœ… éœ€è¦å¿« |
| **ä¼˜åŒ–å‹å¥½** | å·® | âœ… ç®€å• | å¤æ‚ | âœ… å¿…é¡»ç®€å• |
| **ç›´è§‚æ€§** | ä¸­ | âœ… ç›´è§‚ | ä¸ç›´è§‚ | âœ… éœ€è¦ç›´è§‚ |
| **ç¨³å®šæ€§** | ä¸­ | å¥½ | **æœ€å¥½** | å¥½å³å¯ |

**ç»“è®º**: Catmull-Romåœ¨**æ’å€¼æ€§ã€å±€éƒ¨æ€§ã€è®¡ç®—æ•ˆç‡ã€ä¼˜åŒ–å‹å¥½**æ–¹é¢å®Œç¾åŒ¹é…è½¦é“SLAMéœ€æ±‚,æ˜¯æœ€ä½³é€‰æ‹©!

---

## æœ¬é¡¹ç›®ä¸­Catmull-Romæ§åˆ¶ç‚¹çš„é€‰å–ç®—æ³•

### æ ¸å¿ƒé—®é¢˜: æ§åˆ¶ç‚¹å¿…é¡»åœ¨å“ªæ¡"çº¿"ä¸Š?

è¿™æ˜¯ä¸€ä¸ª**éå¸¸å…³é”®çš„é—®é¢˜**,ç›´æ¥å½±å“SLAMç³»ç»Ÿçš„è®¾è®¡ã€‚ç­”æ¡ˆåˆ†ä¸¤ä¸ªé˜¶æ®µ:

#### é˜¶æ®µ1: åˆå§‹åŒ– (ç¬¬ä¸€æ¬¡è§‚æµ‹åˆ°è½¦é“çº¿)
âœ… **æ§åˆ¶ç‚¹å¿…é¡»åœ¨"æ„ŸçŸ¥ç»™çš„ç‚¹é›†åˆ"è¡¨ç¤ºçš„çº¿ä¸Š**

```python
# ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™æ¡è½¦é“çº¿
if lane_id not in map:
    # ä»æ„ŸçŸ¥ç½‘ç»œçš„æ£€æµ‹ç»“æœä¸­æå–æ§åˆ¶ç‚¹
    detected_points = perception_network.detect()  # ä¸Šæ¸¸PersFormerç»™çš„ç‚¹äº‘
    control_points = skeleton_extraction(detected_points)  # ä»æ£€æµ‹ç‚¹äº‘æå–
    
    # åˆ›å»ºCatmull-Romæ›²çº¿
    lane_curve = CatmullRomSpline(control_points)
    map[lane_id] = lane_curve
```

**ä¸ºä»€ä¹ˆ?**
- æ­¤æ—¶åœ°å›¾ä¸­è¿˜**æ²¡æœ‰**è¿™æ¡è½¦é“çº¿
- å¿…é¡»**åŸºäºå½“å‰è§‚æµ‹**åˆå§‹åŒ–
- æ§åˆ¶ç‚¹æ¥æºäºæ£€æµ‹ç‚¹äº‘,è‡ªç„¶"åœ¨çº¿ä¸Š"

#### é˜¶æ®µ2: æ›´æ–° (åç»­å¸§å†æ¬¡è§‚æµ‹åˆ°åŒä¸€è½¦é“çº¿)
âš ï¸ **æ§åˆ¶ç‚¹å¯ä»¥åœ¨"å†å²åœ°å›¾"è¡¨ç¤ºçš„çº¿ä¸Š,ä½†ä¼šç”¨æ–°è§‚æµ‹ä¼˜åŒ–**

```python
# åç»­å¸§å†æ¬¡çœ‹åˆ°è¿™æ¡è½¦é“çº¿
if lane_id in map:
    # å½“å‰åœ°å›¾ä¸­çš„æ§åˆ¶ç‚¹
    map_control_points = map[lane_id].get_control_points()
    
    # æ–°æ£€æµ‹åˆ°çš„ç‚¹äº‘
    new_detected_points = perception_network.detect()
    
    # ä¸¤ç§ç­–ç•¥:
    # ç­–ç•¥A: æ‰©å±•åœ°å›¾(å¢é‡å¼å»ºå›¾)
    new_control_points = skeleton_extraction(new_detected_points)
    map[lane_id].extend(new_control_points)  # æ·»åŠ æ–°æ§åˆ¶ç‚¹
    
    # ç­–ç•¥B: å› å­å›¾ä¼˜åŒ–(ç²¾ç‚¼å·²æœ‰æ§åˆ¶ç‚¹)
    # æ§åˆ¶ç‚¹ä½ç½®ä¼šè¢«ä¼˜åŒ–,ä¸å†ä¸¥æ ¼åœ¨"æ£€æµ‹ç‚¹äº‘"ä¸Š
    # è€Œæ˜¯åœ¨èåˆå¤šå¸§è§‚æµ‹åçš„"æœ€ä¼˜ä¼°è®¡"ä¸Š
    optimized_control_points = factor_graph_optimize(
        map_control_points,      # å…ˆéªŒ(æ¥è‡ªå†å²)
        new_detected_points      # è§‚æµ‹(æ¥è‡ªå½“å‰)
    )
    map[lane_id].update(optimized_control_points)
```

**å…³é”®æ´å¯Ÿ**: 
- âœ… **åˆå§‹åŒ–**: æ§åˆ¶ç‚¹ âˆˆ æ£€æµ‹ç‚¹äº‘
- âš ï¸ **ä¼˜åŒ–å**: æ§åˆ¶ç‚¹ âˆˆ æœ€ä¼˜ä¼°è®¡(å¯èƒ½ç•¥åç¦»ä»»ä¸€å¸§çš„æ£€æµ‹)
- âœ… **çº¦æŸ**: Catmull-Romæ›²çº¿ä»ç„¶é€šè¿‡æ§åˆ¶ç‚¹

### è¯¦ç»†åˆ†æ: ä¸‰ä¸ª"çº¿"çš„æ¦‚å¿µ

ä¸ºäº†å½»åº•ç†è§£,æˆ‘ä»¬åŒºåˆ†ä¸‰ç§"çº¿":

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. çœŸå®è½¦é“çº¿ (Ground Truth)                             â”‚
â”‚    â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                           â”‚
â”‚    ç‰©ç†ä¸–ç•Œä¸­å®é™…çš„è½¦é“æ ‡çº¿                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“ æ„ŸçŸ¥æ£€æµ‹(æœ‰å™ªå£°)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. æ„ŸçŸ¥æ£€æµ‹çš„çº¿ (Detection - æ¯ä¸€å¸§)                      â”‚
â”‚    Frame t:   â— â— â— â— â— â— â— â—  (æ£€æµ‹ç‚¹äº‘,æœ‰å™ªå£°)         â”‚
â”‚    Frame t+1:   â— â— â— â— â— â— â—  (ä¸åŒå¸§,å™ªå£°ä¸åŒ)         â”‚
â”‚    Frame t+2: â— â— â— â— â— â— â— â—                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“ SLAMå»ºå›¾ä¸ä¼˜åŒ–
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. åœ°å›¾ä¸­çš„çº¿ (Map - æ§åˆ¶ç‚¹+Catmull-Rom)                  â”‚
â”‚    æ§åˆ¶ç‚¹:    â—â•â•â•â—â•â•â•â—â•â•â•â—â•â•â•â—                          â”‚
â”‚    æ›²çº¿:      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                          â”‚
â”‚    (èåˆå¤šå¸§è§‚æµ‹,æ¥è¿‘Ground Truth)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æœ¬é¡¹ç›®çš„ç­–ç•¥**:

| é˜¶æ®µ | æ§åˆ¶ç‚¹ä½ç½® | æ‰€åœ¨çš„"çº¿" | ä»£ç ä½ç½® |
|------|-----------|-----------|---------|
| **åˆå§‹åŒ–** | ä»æ£€æµ‹ç‚¹äº‘æå– | æ„ŸçŸ¥æ£€æµ‹çš„çº¿ | `init_ctrl_pts()` |
| **æ‰©å±•** | ä»æ–°æ£€æµ‹ç‚¹äº‘æå– | æ–°æ£€æµ‹çš„çº¿ | `update_ctrl_pts()` |
| **ä¼˜åŒ–** | èåˆå¤šå¸§è§‚æµ‹ | åœ°å›¾ä¼°è®¡çš„çº¿ | `factor_graph_optimize()` |

### å®é™…ä»£ç ä¸­çš„ä½“ç°

#### åˆå§‹åŒ–: æ§åˆ¶ç‚¹åœ¨"æ£€æµ‹çº¿"ä¸Š

```python
# lane_slam/system/lane_opt.py ç¬¬381è¡Œ
if lane_feature_w.id not in self.lanes_in_map:
    # ç¬¬ä¸€æ¬¡è§åˆ°è¿™æ¡è½¦é“çº¿
    self.lanes_in_map[lane_feature_w.id] = lane_feature_w
    
    # ä»æ£€æµ‹ç‚¹äº‘åˆå§‹åŒ–æ§åˆ¶ç‚¹
    self.lanes_in_map[lane_feature_w.id].init_ctrl_pts(
        lane_feature_w,           # â† åŒ…å«æ£€æµ‹ç‚¹äº‘ lane_w.get_xyzs()
        self.cur_frame.T_cw
    )
```

```python
# lane_slam/lane_feature.py ç¬¬80è¡Œ
def init_ctrl_pts(self, lane_w, cur_pose_cw):
    """åˆå§‹åŒ–æ§åˆ¶ç‚¹ - ä»æ£€æµ‹ç‚¹äº‘ä¸­æå–"""
    # lane_w.get_xyzs() å°±æ˜¯æ„ŸçŸ¥ç½‘ç»œç»™çš„ç‚¹äº‘!
    self.get_skeleton(lane_w.get_xyzs(), polyline=lane_w.polyline)
    
    # æ­¤æ—¶: æ§åˆ¶ç‚¹ âˆˆ æ£€æµ‹ç‚¹äº‘
    # Catmull-Romæ›²çº¿é€šè¿‡è¿™äº›æ§åˆ¶ç‚¹
```

#### æ›´æ–°: æ‰©å±•åœ°å›¾,æ§åˆ¶ç‚¹ä»åœ¨"æ–°æ£€æµ‹çº¿"ä¸Š

```python
# lane_slam/system/lane_opt.py ç¬¬383è¡Œ
else:
    # å·²ç»è§è¿‡è¿™æ¡è½¦é“çº¿,æ‰©å±•åœ°å›¾
    self.lanes_in_map[lane_feature_w.id].update_ctrl_pts(lane_feature_w)
```

```python
# lane_slam/lane_feature.py ç¬¬114è¡Œ
def update_ctrl_pts(self, lane_w):
    """æ›´æ–°æ§åˆ¶ç‚¹ - ä»æ–°æ£€æµ‹ç‚¹äº‘æ‰©å±•"""
    lane_w_points = lane_w.get_xyzs()  # æ–°æ£€æµ‹çš„ç‚¹äº‘
    
    # ä»æœ€åä¸€ä¸ªæ§åˆ¶ç‚¹ç»§ç»­,æå–æ–°çš„æ§åˆ¶ç‚¹
    succ = self.get_skeleton(
        lane_w_points,                    # æ–°æ£€æµ‹ç‚¹äº‘
        self.ctrl_pts.get_xyz(-1),       # ä»å·²æœ‰æ§åˆ¶ç‚¹æœ«å°¾ç»§ç»­
        polyline=lane_w.polyline
    )
    
    # æ–°å¢çš„æ§åˆ¶ç‚¹ âˆˆ æ–°æ£€æµ‹ç‚¹äº‘
```

#### ä¼˜åŒ–: æ§åˆ¶ç‚¹åœ¨"ä¼˜åŒ–åçš„åœ°å›¾çº¿"ä¸Š

```python
# lane_slam/system/lane_opt.py ç¬¬156è¡Œ
# å› å­å›¾ä¼˜åŒ–
result = self.optimizer.optimize()

# ä¼˜åŒ–å,æ§åˆ¶ç‚¹ä½ç½®ä¼šè°ƒæ•´
for key in result.keys():
    optimized_position = result.atPoint3(key)
    # æ­¤æ—¶: æ§åˆ¶ç‚¹ â‰ˆ å¤šå¸§è§‚æµ‹çš„èåˆç»“æœ
    # å¯èƒ½ä¸ä¸¥æ ¼åœ¨ä»»ä¸€å¸§çš„æ£€æµ‹ç‚¹äº‘ä¸Š
    # ä½†æ›´æ¥è¿‘çœŸå®è½¦é“çº¿
```

**å…³é”®**: ä¼˜åŒ–åçš„æ§åˆ¶ç‚¹æ»¡è¶³:
```python
# æœ€å°åŒ–æ‰€æœ‰å¸§è§‚æµ‹çš„è¯¯å·®
min Î£ ||detection_frame_i - catmull_rom(control_points)||Â²

# è€Œä¸æ˜¯ä¸¥æ ¼åœ¨æŸä¸€å¸§çš„æ£€æµ‹ç‚¹ä¸Š
```

### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡?

#### âŒ å¦‚æœå¼ºåˆ¶æ§åˆ¶ç‚¹æ°¸è¿œåœ¨"æ£€æµ‹çº¿"ä¸Š

```python
# æ¯æ¬¡éƒ½é‡æ–°ä»æ£€æµ‹ç‚¹äº‘æå–
for each_frame:
    detected_points = detect()
    control_points = extract_from_detection(detected_points)
    # é—®é¢˜: æ§åˆ¶ç‚¹ä½ç½®æŠ–åŠ¨!
```

**é—®é¢˜**:
1. æ£€æµ‹å™ªå£° â†’ æ§åˆ¶ç‚¹æŠ–åŠ¨ â†’ åœ°å›¾ä¸ç¨³å®š
2. æ— æ³•èåˆå¤šå¸§ä¿¡æ¯
3. åœ°å›¾è´¨é‡ â‰¤ å•å¸§æ£€æµ‹è´¨é‡

#### âœ… æœ¬é¡¹ç›®çš„è®¾è®¡: åˆå§‹åŒ–ç”¨æ£€æµ‹,ä¼˜åŒ–åèåˆ

```python
# åˆå§‹åŒ–: åŸºäºæ£€æµ‹
control_points_init = extract_from_detection(frame_0)

# ä¼˜åŒ–: èåˆå¤šå¸§
control_points_opt = optimize(
    control_points_init,      # åˆå€¼
    [frame_0, frame_1, ..., frame_n]  # å¤šå¸§è§‚æµ‹
)

# ç»“æœ: control_points_opt æ›´å‡†ç¡®,æ›´ç¨³å®š
```

**ä¼˜åŠ¿**:
1. âœ… åˆå§‹åŒ–å¯é (åŸºäºæ£€æµ‹)
2. âœ… ä¼˜åŒ–åæ›´å‡†ç¡®(èåˆå¤šå¸§)
3. âœ… åœ°å›¾ç¨³å®š(å¹³æ»‘æŠ–åŠ¨)
4. âœ… Catmull-Romæ€§è´¨ä¸å˜(ä»é€šè¿‡æ§åˆ¶ç‚¹)

### å¯è§†åŒ–è¯´æ˜

```
æ—¶é—´çº¿:

t=0 (åˆå§‹åŒ–)
æ£€æµ‹ç‚¹äº‘: â— â— â— â— â— â— â—
æ§åˆ¶ç‚¹:   â—â•â•â•â—â•â•â•â—        â† ä»æ£€æµ‹ç‚¹äº‘æå–
æ›²çº¿:     â•â•â•â•â•â•â•â•â•â•â•â•

t=1 (ç¬¬äºŒæ¬¡è§‚æµ‹,æ‰©å±•)
æ–°æ£€æµ‹:             â— â— â— â— â—
æ§åˆ¶ç‚¹:   â—â•â•â•â—â•â•â•â—â•â•â•â—      â† æ‰©å±•æ–°æ§åˆ¶ç‚¹
æ›²çº¿:     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

t=2,3,4... (å¤šæ¬¡è§‚æµ‹,ä¼˜åŒ–)
æ£€æµ‹1:    â— â— â— â— â—  â— â— â—
æ£€æµ‹2:    â—  â— â—  â— â— â—  â—
æ£€æµ‹3:     â— â—  â— â— â— â— â—
         â†“ å› å­å›¾ä¼˜åŒ– â†“
æ§åˆ¶ç‚¹:   â—â•â•â•â—â•â•â•â—â•â•â•â—      â† ä¼˜åŒ–åä½ç½®
æ›²çº¿:     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â† æ›´æ¥è¿‘çœŸå®è½¦é“çº¿
         (ä¸ä¸¥æ ¼åœ¨ä»»ä¸€å¸§æ£€æµ‹ä¸Š,ä½†ç»¼åˆæœ€ä¼˜)
```

### æ€»ç»“: ä¸‰ä¸ªé˜¶æ®µçš„"çº¿"

| é˜¶æ®µ | æ§åˆ¶ç‚¹å¿…é¡»åœ¨... | åŸå›  | ä¸¥æ ¼æ€§ |
|------|---------------|------|-------|
| **åˆå§‹åŒ–** | æ„ŸçŸ¥æ£€æµ‹çš„çº¿ | æ²¡æœ‰å…ˆéªŒ,å¿…é¡»ç”¨æ£€æµ‹åˆå§‹åŒ– | âœ… ä¸¥æ ¼ |
| **æ‰©å±•** | æ–°æ£€æµ‹çš„çº¿ | å¢é‡å»ºå›¾,æ‰©å±•æ–°åŒºåŸŸ | âœ… ä¸¥æ ¼ |
| **ä¼˜åŒ–** | ä¼˜åŒ–ä¼°è®¡çš„çº¿ | èåˆå¤šå¸§,æœ€ä¼˜ä¼°è®¡ | âš ï¸ ä¸ä¸¥æ ¼ |

**æ ¸å¿ƒåŸåˆ™**:
- ğŸ“ **åˆå§‹åŒ–**: æ§åˆ¶ç‚¹ âˆˆ æ£€æµ‹ç‚¹äº‘ (å¿…é¡»)
- ğŸ”„ **ä¼˜åŒ–**: æ§åˆ¶ç‚¹ âˆˆ æœ€ä¼˜ä¼°è®¡ (å¯åç¦»å•å¸§æ£€æµ‹)
- âœ… **ä¸å˜æ€§**: Catmull-Romå§‹ç»ˆé€šè¿‡æ§åˆ¶ç‚¹ (è¿™æ˜¯å…³é”®!)

---

### ç®—æ³•æ¦‚è¿°

**æ ¸å¿ƒæ€æƒ³**: ä»è½¦é“çº¿ç‚¹äº‘ä¸­,æ²¿ç€è½¦é“æ–¹å‘,ä»¥**å›ºå®šå¼¦é•¿é—´éš”**æå–æ§åˆ¶ç‚¹,å½¢æˆè½¦é“çº¿çš„"éª¨æ¶"(skeleton)ã€‚

**å®ç°ä½ç½®**: `lane_slam/lane_feature.py` çš„ `get_skeleton()` æ–¹æ³•

### ç®—æ³•æµç¨‹

#### 1. åˆå§‹åŒ–é˜¶æ®µ (`init_ctrl_pts`)

```python
def init_ctrl_pts(self, lane_w, cur_pose_cw):
    """åˆå§‹åŒ–æ§åˆ¶ç‚¹åºåˆ—"""
    # æ­¥éª¤1: æå–éª¨æ¶ç‚¹
    self.get_skeleton(lane_w.get_xyzs(), polyline=lane_w.polyline)
    
    # æ­¥éª¤2: ç¡®å®šæ–¹å‘(ç¡®ä¿æ§åˆ¶ç‚¹ä»è¿‘åˆ°è¿œæ’åˆ—)
    head = self.ctrl_pts.get_xyz(0)
    tail = self.ctrl_pts.get_xyz(-1)
    # è½¬æ¢åˆ°ç›¸æœºåæ ‡ç³»
    head_cam = cur_pose_cw[:3, :3].dot(head) + cur_pose_cw[:3, 3]
    tail_cam = cur_pose_cw[:3, :3].dot(tail) + cur_pose_cw[:3, 3]
    
    # å¦‚æœå¤´éƒ¨æ¯”å°¾éƒ¨è¿œ,åˆ™åè½¬æ§åˆ¶ç‚¹åºåˆ—
    if np.linalg.norm(head_cam) > np.linalg.norm(tail_cam):
        self.ctrl_pts.reverse()
```

**è®¾è®¡æ„å›¾**: 
- ç¡®ä¿æ§åˆ¶ç‚¹åºåˆ—æ€»æ˜¯ä»è½¦è¾†é™„è¿‘å¼€å§‹,å‘è¿œå¤„å»¶ä¼¸
- ä¾¿äºå¢é‡å¼æ›´æ–°åœ°å›¾

#### 2. éª¨æ¶æå–ç®—æ³• (`get_skeleton`)

**è¾“å…¥**: 
- `origin_points`: è½¦é“çº¿çš„å¯†é›†ç‚¹äº‘ (NÃ—3)
- `initial_point`: èµ·å§‹ç‚¹(å¯é€‰)
- `polyline`: è½¦é“çº¿çš„å¤šé¡¹å¼æ‹Ÿåˆæ¨¡å‹

**è¾“å‡º**: 
- å­˜å‚¨åœ¨ `self.ctrl_pts` ä¸­çš„æ§åˆ¶ç‚¹åºåˆ—

**ç®—æ³•æ­¥éª¤**:

```python
def get_skeleton(self, origin_points, initial_point=None, polyline=None):
    """éª¨æ¶æå–ç®—æ³•"""
    
    # æ­¥éª¤1: ç¡®å®šåˆå§‹ç‚¹
    if initial_point is None:
        initial_point = origin_points[0]
        self.ctrl_pts.add(initial_point)
    
    # æ­¥éª¤2: è¿­ä»£ç”Ÿæˆæ§åˆ¶ç‚¹
    while True:
        # 2.1 è¿‡æ»¤è§’åº¦
        origin_points = self.get_pts_to_add(origin_points)
        if origin_points.shape[0] == 0:
            return True
        
        # 2.2 åœ¨åŠå¾„å†…æ‰¾æœ€è¿œç‚¹
        no_assigned = list(range(origin_points.shape[0]))
        
        if origin_points.shape[0] <= 15:
            inner_border, outer_border = self.find_border_point(
                initial_point, origin_points, no_assigned)
        else:
            # ä½¿ç”¨KDTreeåŠ é€Ÿ
            inner_border, outer_border = self.find_border_point_kdtree(
                initial_point, origin_points, no_assigned)
        
        # 2.3 ç¡®å®šä¸‹ä¸€ä¸ªæ§åˆ¶ç‚¹
        if outer_border is None:
            # æ‰€æœ‰ç‚¹éƒ½åœ¨åŠå¾„å†…,ä½¿ç”¨å†…è¾¹ç•Œç‚¹
            next_point = self.get_next_node(
                inner_border, current_center, 
                self.ctrl_points_chord, polyline)
        else:
            # è¿˜æœ‰ç‚¹åœ¨åŠå¾„å¤–,ä½¿ç”¨å¤–è¾¹ç•Œç‚¹
            next_point = self.get_next_node(
                outer_border, current_center, 
                self.ctrl_points_chord, polyline)
        
        # 2.4 æ·»åŠ æ§åˆ¶ç‚¹(å¤´éƒ¨æˆ–å°¾éƒ¨)
        self.ctrl_pts.append(next_point)  # æˆ– self.ctrl_pts.add()
        
        # 2.5 æ›´æ–°åˆå§‹ç‚¹å’Œå‰©ä½™ç‚¹äº‘
        initial_point = next_point
        origin_points = origin_points[no_assigned]
```

#### 3. å…³é”®å­ç®—æ³•

**A. è§’åº¦è¿‡æ»¤ (`get_pts_to_add`)**

```python
def get_pts_to_add(self, points):
    """è¿‡æ»¤æ‰ä¸è½¦é“çº¿æ–¹å‘å¤¹è§’è¿‡å¤§çš„ç‚¹"""
    ctrl_pts_size = self.ctrl_pts.size()
    if ctrl_pts_size < 2:
        return points
    
    # è®¡ç®—å¤´å°¾æ–¹å‘å‘é‡
    normal_a = self.ctrl_pts.get_xyz(0) - self.ctrl_pts.get_xyz(1)
    normal_b = self.ctrl_pts.get_xyz(-1) - self.ctrl_pts.get_xyz(-2)
    
    pts_to_add = []
    for pt in points:
        d_a = pt - self.ctrl_pts.get_xyz(0)
        d_b = pt - self.ctrl_pts.get_xyz(-1)
        
        # è®¡ç®—å¤¹è§’ä½™å¼¦å€¼
        cos_a = np.dot(d_a, normal_a) / (norm(d_a) * norm(normal_a))
        cos_b = np.dot(d_b, normal_b) / (norm(d_b) * norm(normal_b))
        
        # è§’åº¦é˜ˆå€¼(é»˜è®¤90åº¦)
        thd = np.cos(np.deg2rad(cfg.skeleton_angle_thd))
        
        # ä¿ç•™æ–¹å‘ä¸€è‡´çš„ç‚¹
        if cos_a > thd or cos_b > thd:
            pts_to_add.append(pt)
    
    return np.array(pts_to_add)
```

**è®¾è®¡æ„å›¾**: æ’é™¤åç¦»è½¦é“çº¿ä¸»æ–¹å‘çš„å™ªå£°ç‚¹

**B. æ‰¾è¾¹ç•Œç‚¹ (`find_border_point_kdtree`)**

```python
def find_border_point_kdtree(self, query, points, no_assigned):
    """åœ¨æ§åˆ¶ç‚¹åŠå¾„å†…æ‰¾æœ€è¿œç‚¹(å†…è¾¹ç•Œ),åŠå¾„å¤–æ‰¾æœ€è¿‘ç‚¹(å¤–è¾¹ç•Œ)"""
    kdtree = KDTree(points)
    upper_bound = cfg.ctrl_points_chord  # é»˜è®¤3.0ç±³
    
    # æŸ¥è¯¢åŠå¾„å†…çš„ç‚¹æ•°é‡
    num = kdtree.query_ball_point(query, r=upper_bound, return_length=True)
    dist, idx = kdtree.query(query, k=num+1)
    
    # å†…è¾¹ç•Œ: åŠå¾„å†…æœ€è¿œç‚¹
    inner_border = None if num == 0 else points[idx[-2]]
    
    # å¤–è¾¹ç•Œ: åŠå¾„å¤–æœ€è¿‘ç‚¹
    if num == 0:
        outer_border = None if dist == np.inf else points[idx]
        no_assigned.remove(idx)
    else:
        outer_border = None if dist[-1] == np.inf else points[idx[-1]]
        for i in idx[:-1]:
            no_assigned.remove(i)  # æ ‡è®°ä¸ºå·²ä½¿ç”¨
    
    return inner_border, outer_border
```

**C. è®¡ç®—ä¸‹ä¸€ä¸ªæ§åˆ¶ç‚¹ (`get_next_node`)**

è¿™æ˜¯ç®—æ³•çš„æ ¸å¿ƒ,ç¡®ä¿æ§åˆ¶ç‚¹**åœ¨è½¦é“çº¿ä¸Š**ä¸”**é—´éš”å›ºå®š**:

```python
def get_next_node(self, query, center, radius, polyline):
    """é€šè¿‡è¿­ä»£æŠ•å½±,è®¡ç®—ä¸‹ä¸€ä¸ªæ§åˆ¶ç‚¹
    
    æ ¸å¿ƒæ€æƒ³:
    1. å°†queryæŠ•å½±åˆ°ä»¥centerä¸ºåœ†å¿ƒã€radiusä¸ºåŠå¾„çš„çƒé¢ä¸Š
    2. å°†çƒé¢ä¸Šçš„ç‚¹æŠ•å½±åˆ°è½¦é“çº¿çš„å¤šé¡¹å¼æ›²çº¿ä¸Š
    3. é‡å¤1-2,ç›´åˆ°æ”¶æ•›
    
    è¿™æ ·å¾—åˆ°çš„ç‚¹æ—¢åœ¨è½¦é“çº¿ä¸Š,åˆä¸centerè·ç¦»ä¸ºradius
    """
    query_new = polyline['rot'].apply(query)
    center_new = polyline['rot'].apply(center)
    last_result = np.array([0, 0, 0])
    
    for i in range(10):  # æœ€å¤šè¿­ä»£10æ¬¡
        # æ­¥éª¤1: æŠ•å½±åˆ°çƒé¢
        nearest_on_circle = self.get_nearest_on_circle(
            query_new, center_new, radius)
        
        # æ­¥éª¤2: æŠ•å½±åˆ°å¤šé¡¹å¼æ›²çº¿
        x = nearest_on_circle[0]
        y_on_polyline = polyline['f_yx'](x)
        z_on_polyline = polyline['f_zx'](x)
        query_new = np.array([x, y_on_polyline, z_on_polyline])
        
        # æ­¥éª¤3: æ£€æŸ¥æ”¶æ•›
        delta = np.linalg.norm(query_new - last_result)
        if delta < 1e-2:
            break
        last_result = query_new
    
    # è½¬æ¢å›ä¸–ç•Œåæ ‡ç³»
    node_on_polyline = polyline['rot'].inv().apply(query_new)
    
    # æœ€åä¸€æ¬¡æŠ•å½±åˆ°çƒé¢,ç¡®ä¿è·ç¦»ç²¾ç¡®
    nearest_on_circle = self.get_nearest_on_circle(
        node_on_polyline, center, radius)
    
    return nearest_on_circle
```

**æ•°å­¦åŸç†**: äº¤æ›¿æŠ•å½±ç®—æ³•
- åœ¨**çƒé¢çº¦æŸ**(è·ç¦»å›ºå®š)å’Œ**æ›²çº¿çº¦æŸ**(åœ¨è½¦é“çº¿ä¸Š)ä¹‹é—´äº¤æ›¿æŠ•å½±
- ç±»ä¼¼äºä¼˜åŒ–ä¸­çš„åæ ‡ä¸‹é™æ³•

### å…³é”®å‚æ•°

åœ¨é…ç½®æ–‡ä»¶ `config/lane_mapping.yaml` ä¸­:

```yaml
lane_mapping:
  ctrl_points_chord: 3.0        # æ§åˆ¶ç‚¹é—´éš”(ç±³)
  skeleton_angle_thd: 90        # è§’åº¦è¿‡æ»¤é˜ˆå€¼(åº¦)
```

**å‚æ•°è¯´æ˜**:
- `ctrl_points_chord`: æ§åˆ¶ç‚¹ä¹‹é—´çš„å¼¦é•¿é—´éš”
  - å¤ªå°: æ§åˆ¶ç‚¹è¿‡å¯†,è®¡ç®—é‡å¤§
  - å¤ªå¤§: æ›²çº¿æ‹Ÿåˆç²¾åº¦ä½
  - **3.0ç±³**: åœ¨ç²¾åº¦å’Œæ•ˆç‡é—´å–å¾—å¹³è¡¡
  
- `skeleton_angle_thd`: ç‚¹ä¸è½¦é“çº¿æ–¹å‘å¤¹è§’é˜ˆå€¼
  - 90åº¦: ä¿ç•™æ‰€æœ‰å‰æ–¹å’Œä¾§æ–¹çš„ç‚¹
  - æ›´å°çš„å€¼: æ›´ä¸¥æ ¼çš„æ–¹å‘çº¦æŸ

### ç®—æ³•ç‰¹ç‚¹

âœ… **ä¼˜åŠ¿**:
1. **è‡ªé€‚åº”**: è‡ªåŠ¨é€‚åº”è½¦é“çº¿çš„å¼¯æ›²ç¨‹åº¦
2. **ç­‰é—´è·**: æ§åˆ¶ç‚¹é—´éš”å‡åŒ€,æ›²çº¿å‚æ•°åŒ–æ›´å‡åŒ€
3. **åœ¨çº¿æ›´æ–°**: æ”¯æŒå¢é‡å¼æ·»åŠ æ–°è§‚æµ‹ç‚¹
4. **é²æ£’æ€§**: é€šè¿‡è§’åº¦è¿‡æ»¤å’ŒKDTreeåŠ é€Ÿ,å¤„ç†å™ªå£°å’Œå¤§æ•°æ®

âš ï¸ **å±€é™**:
1. ä¾èµ–å¤šé¡¹å¼æ‹Ÿåˆçš„è´¨é‡
2. å¯¹èµ·å§‹ç‚¹ä½ç½®æ•æ„Ÿ
3. å¼¯é“å¤„å¯èƒ½éœ€è¦æ›´å¯†é›†çš„æ§åˆ¶ç‚¹

### å¯è§†åŒ–ç¤ºä¾‹

```
åŸå§‹ç‚¹äº‘:        Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·
                 Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·

éª¨æ¶æå–:        â—-------â—-------â—-------â—-------â—-------â—
                 |<-3m-> |<-3m-> |<-3m-> |<-3m-> |<-3m-> |

Catmull-Rom:     â—â•â•â•â•â•â•â•â—â•â•â•â•â•â•â•â—â•â•â•â•â•â•â•â—â•â•â•â•â•â•â•â—â•â•â•â•â•â•â•â—
                 â””â”€æ›²çº¿ç²¾ç¡®é€šè¿‡æ¯ä¸ªæ§åˆ¶ç‚¹
```

### æ›´æ–°æœºåˆ¶ (`update_ctrl_pts`)

```python
def update_ctrl_pts(self, lane_w):
    """å¢é‡å¼æ›´æ–°æ§åˆ¶ç‚¹"""
    lane_w_points = lane_w.get_xyzs()
    
    # ä»æœ€åä¸€ä¸ªæ§åˆ¶ç‚¹ç»§ç»­ç”Ÿæˆ
    succ = self.get_skeleton(
        lane_w_points, 
        self.ctrl_pts.get_xyz(-1),  # ä»å°¾éƒ¨å¼€å§‹
        polyline=lane_w.polyline
    )
    return succ
```

**è®¾è®¡ä¼˜åŠ¿**:
- ä¸é‡æ–°è®¡ç®—æ‰€æœ‰æ§åˆ¶ç‚¹
- åªåœ¨è½¦é“çº¿æœ«ç«¯è¿½åŠ æ–°æ§åˆ¶ç‚¹
- ä¿æŒå†å²æ§åˆ¶ç‚¹ç¨³å®š,æœ‰åˆ©äºSLAMä¼˜åŒ–æ”¶æ•›

---

## è½¦é“çº¿æ•°æ®æ¥æº: ä¸Šæ¸¸æ„ŸçŸ¥ç½‘ç»œçš„è¾“å‡º

### æ•°æ®æµå®Œæ•´é“¾è·¯

ç†è§£SLAMç³»ç»Ÿéœ€è¦æ˜ç¡®**æ•°æ®çš„æ¥æº**ã€‚æœ¬é¡¹ç›®ä¸­,è½¦é“çº¿ç‚¹äº‘æ¥è‡ª**ä¸Šæ¸¸æ„ŸçŸ¥æ¨¡å—**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ„ŸçŸ¥é˜¶æ®µ (Perception)                    â”‚
â”‚                                                            â”‚
â”‚  å•ç›®ç›¸æœºå›¾åƒ (1920Ã—1280 RGB)                              â”‚
â”‚         â†“                                                  â”‚
â”‚  PersFormer 3Dè½¦é“çº¿æ£€æµ‹ç½‘ç»œ                               â”‚
â”‚  (åŸºäºTransformerçš„ç«¯åˆ°ç«¯æ£€æµ‹)                             â”‚
â”‚         â†“                                                  â”‚
â”‚  3Dè½¦é“çº¿ç‚¹äº‘ (æ¯æ¡NÃ—3, ä¸–ç•Œåæ ‡ç³»)                         â”‚
â”‚  {                                                         â”‚
â”‚    'xyz': [[x1,y1,z1], [x2,y2,z2], ...],                  â”‚
â”‚    'category': lane_type,                                 â”‚
â”‚    'visibility': [1, 1, 0, ...]                           â”‚
â”‚  }                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â†“ è¾“å…¥åˆ°SLAM
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   SLAMé˜¶æ®µ (æœ¬é¡¹ç›®)                        â”‚
â”‚                                                            â”‚
â”‚  1. é¢„å¤„ç†:                                                â”‚
â”‚     - é™é‡‡æ · (0.5mé—´éš”)                                    â”‚
â”‚     - å»å™ªå¹³æ»‘                                             â”‚
â”‚     - è·ç¦»æ’åº                                             â”‚
â”‚                                                            â”‚
â”‚  2. æ§åˆ¶ç‚¹æå– (éª¨æ¶ç®—æ³•):                                  â”‚
â”‚     æ£€æµ‹ç‚¹äº‘ â†’ éª¨æ¶æå– â†’ æ§åˆ¶ç‚¹ (3mé—´éš”)                   â”‚
â”‚                                                            â”‚
â”‚  3. Catmull-Romå»ºæ¨¡:                                       â”‚
â”‚     æ§åˆ¶ç‚¹ â†’ Catmull-Romæ›²çº¿ â†’ åœ°å›¾è¡¨ç¤º                    â”‚
â”‚                                                            â”‚
â”‚  4. SLAMä¼˜åŒ–:                                              â”‚
â”‚     å¤šå¸§è§‚æµ‹ â†’ å› å­å›¾ä¼˜åŒ– â†’ ç²¾ç‚¼åœ°å›¾                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ„ŸçŸ¥ç½‘ç»œ: PersFormer

**ç½‘ç»œä»‹ç»**:
- **è®ºæ–‡**: "PersFormer: 3D Lane Detection via Perspective Transformer"
- **ä»“åº“**: https://github.com/OpenDriveLab/PersFormer_3DLane
- **è¾“å…¥**: å•ç›®RGBå›¾åƒ
- **è¾“å‡º**: BEVè§†å›¾ä¸‹çš„3Dè½¦é“çº¿ç‚¹äº‘

**æ•°æ®æ ¼å¼** (å­˜å‚¨åœ¨rosbagä¸­):

```python
# ä»rosbagè¯»å–æ„ŸçŸ¥ç»“æœ
/lanes_predict:  # PersFormeræ£€æµ‹ç»“æœ
  header:
    stamp: 1234567890.123456
  lanes:
    - xyz: [[10.2, -1.8, 0.0], [11.5, -1.8, 0.0], ...]  # 3Dç‚¹äº‘
      category: 1  # è½¦é“çº¿ç±»å‹
      visibility: [1, 1, 1, ...]  # å¯è§æ€§

/lanes_gt:  # Ground Truth (ç”¨äºè¯„ä¼°)
  # æ ¼å¼åŒä¸Š
  
/gt_pose_wc:  # è½¦è¾†ä½å§¿ (æ¥è‡ªGPS/IMUæˆ–çœŸå€¼)
  position: [x, y, z]
  orientation: [qx, qy, qz, qw]
```

### ä»£ç ä¸­çš„æ•°æ®è¯»å–

```python
# lane_slam/system/lane_ui.py
def load_data_from_bag(self):
    """ä»rosbagåŠ è½½æ•°æ®"""
    for topic, msg, t in self.bag.read_messages(
        topics=['/gt_pose_wc', '/lanes_gt', '/lanes_predict']):
        
        if topic == '/lanes_predict':
            # PersFormeræ£€æµ‹ç»“æœ â† æ„ŸçŸ¥ç½‘ç»œè¾“å‡º
            lanes_predict = lanemsg_to_list(msg)
            
            # é¢„å¤„ç†
            lanes_predict = self.preprocess_lanes(lanes_predict)

def preprocess_lanes(self, lanes):
    """é¢„å¤„ç†æ„ŸçŸ¥ç½‘ç»œè¾“å‡º"""
    for lane in lanes:
        xyz = lane['xyz']  # â† åŸå§‹æ£€æµ‹ç‚¹äº‘
        
        # é™é‡‡æ ·
        xyz = points_downsample(xyz, self.pp_ds)
        
        # å»å™ªå¹³æ»‘
        xyz = lane_denoise(xyz, smooth=True, interval=self.pp_ds)
        
        # æŒ‰è·ç¦»æ’åº
        xyz = xyz[np.argsort(np.linalg.norm(xyz, axis=1))]
        
        lane['xyz'] = xyz  # â† é¢„å¤„ç†åçš„ç‚¹äº‘
    return lanes
```

### ä¸ºä»€ä¹ˆå¿…é¡»åŸºäºæ„ŸçŸ¥è¾“å‡º?

#### âŒ ä¸èƒ½ç›´æ¥ä»åœ°å›¾æ¨æ–­

```python
# é”™è¯¯åšæ³•: æ²¡æœ‰æ„ŸçŸ¥,å‡­ç©ºå»ºå›¾
map = {}
while True:
    # âŒ æ²¡æœ‰è§‚æµ‹,æ€ä¹ˆçŸ¥é“è½¦é“çº¿åœ¨å“ª?
    map.update(???)  # æ— æ³•å»ºå›¾!
```

#### âœ… å¿…é¡»æœ‰æ„ŸçŸ¥è§‚æµ‹

```python
# æ­£ç¡®åšæ³•: æ„ŸçŸ¥æä¾›è§‚æµ‹
map = {}
while True:
    # 1. æ„ŸçŸ¥æ£€æµ‹ (è§‚æµ‹)
    detected_lanes = perception_network.detect(image)
    
    # 2. SLAMå¤„ç† (å»ºå›¾+å®šä½)
    map, pose = slam_system.update(detected_lanes, odometry)
```

**SLAMçš„æœ¬è´¨**:
```
SLAM = æ„ŸçŸ¥è§‚æµ‹ + è¿åŠ¨ä¼°è®¡ + æ•°æ®å…³è” + çŠ¶æ€ä¼˜åŒ–

æ²¡æœ‰æ„ŸçŸ¥è§‚æµ‹,SLAMæ— ä»è°ˆèµ·!
```

### æ„ŸçŸ¥è´¨é‡å¯¹SLAMçš„å½±å“

| æ„ŸçŸ¥è´¨é‡ | SLAMè¡¨ç° | ä¸¾ä¾‹ |
|---------|---------|------|
| **é«˜è´¨é‡** | âœ… å‡†ç¡®å»ºå›¾,ç¨³å®šå®šä½ | ç†æƒ³æ¡ä»¶,æ£€æµ‹ç²¾åº¦é«˜ |
| **ä¸­ç­‰è´¨é‡** | âš ï¸ éœ€è¦ä¼˜åŒ–è¡¥å¿ | ä¸€èˆ¬å¤©æ°”,éƒ¨åˆ†é®æŒ¡ |
| **ä½è´¨é‡** | âŒ å…³è”å¤±è´¥,æ¼‚ç§» | å¼ºå…‰/å¤œé—´,æ£€æµ‹å¤±è´¥ |
| **å®Œå…¨å¤±è´¥** | âŒ ç³»ç»Ÿé™çº§ | æ— è½¦é“çº¿è·¯æ®µ |

**æœ¬é¡¹ç›®çš„ç­–ç•¥**:
```python
# é²æ£’æ€§æªæ–½
if detection_quality > threshold:
    # ä½¿ç”¨æ£€æµ‹ç»“æœæ›´æ–°åœ°å›¾
    map.update(detected_lanes)
else:
    # ä»…ä½¿ç”¨é‡Œç¨‹è®¡æ¨ç®—
    pose = odometry_predict(last_pose)
```

### æ„ŸçŸ¥ä¸SLAMçš„å…³ç³»

```
æ„ŸçŸ¥ (Perception):
- è¾“å…¥: ä¼ æ„Ÿå™¨æ•°æ® (å›¾åƒ/ç‚¹äº‘)
- è¾“å‡º: è¯­ä¹‰ä¿¡æ¯ (è½¦é“çº¿/éšœç¢ç‰©)
- ç‰¹ç‚¹: å³æ—¶,å±€éƒ¨,æœ‰å™ªå£°

       â†“ è¾“å‡ºç»™ â†“

SLAM (å®šä½ä¸å»ºå›¾):
- è¾“å…¥: æ„ŸçŸ¥ç»“æœ + è¿åŠ¨ä¿¡æ¯
- è¾“å‡º: å…¨å±€åœ°å›¾ + ç²¾ç¡®ä½å§¿
- ç‰¹ç‚¹: ç´¯ç§¯,å…¨å±€,èåˆä¼˜åŒ–

       â†“ åé¦ˆç»™ â†“

è§„åˆ’æ§åˆ¶:
- è¾“å…¥: åœ°å›¾ + ä½å§¿
- è¾“å‡º: è½¨è¿¹ + æ§åˆ¶æŒ‡ä»¤
```

**å…³é”®æ´å¯Ÿ**:
1. ğŸ“· **æ„ŸçŸ¥æ˜¯SLAMçš„çœ¼ç›** - æä¾›è§‚æµ‹
2. ğŸ§  **SLAMæ˜¯æ„ŸçŸ¥çš„å¤§è„‘** - èåˆå†å²,æ¶ˆé™¤å™ªå£°
3. ğŸ¤ **äºŒè€…ååŒå·¥ä½œ** - æ„ŸçŸ¥â†’SLAMâ†’è§„åˆ’

### æœ¬é¡¹ç›®çš„å®Œæ•´æ•°æ®é“¾

```python
# å®Œæ•´æµç¨‹
class MonoLaneMapping:
    def run(self):
        # 1. è¯»å–æ„ŸçŸ¥ç»“æœ (æ¥è‡ªrosbag,ç¦»çº¿)
        for frame in self.dataset:
            # 1.1 ä¸Šæ¸¸æ„ŸçŸ¥ç½‘ç»œå·²ç»è¿è¡Œ,ç»“æœå­˜åœ¨rosbagä¸­
            detected_lanes = frame.get_lanes_predict()  # PersFormerè¾“å‡º
            odometry = frame.get_odometry()
            
            # 1.2 é¢„å¤„ç†
            detected_lanes = self.preprocess(detected_lanes)
            
            # 2. SLAMå¤„ç†
            # 2.1 æ•°æ®å…³è”
            associations = self.associate(detected_lanes, self.map)
            
            # 2.2 æå–/æ›´æ–°æ§åˆ¶ç‚¹
            for lane_id, detected_lane in associations:
                if lane_id not in self.map:
                    # åˆå§‹åŒ–: ä»æ£€æµ‹ç‚¹äº‘æå–æ§åˆ¶ç‚¹
                    ctrl_pts = self.extract_skeleton(detected_lane)
                    self.map[lane_id] = CatmullRomSpline(ctrl_pts)
                else:
                    # æ›´æ–°: æ‰©å±•æ§åˆ¶ç‚¹
                    self.map[lane_id].extend(detected_lane)
            
            # 2.3 å› å­å›¾ä¼˜åŒ–
            self.map, self.pose = self.optimize(
                self.map,
                detected_lanes,
                odometry
            )
        
        return self.map
```

**æ•°æ®æµæ€»ç»“**:
```
PersFormeræ£€æµ‹ â†’ rosbagå­˜å‚¨ â†’ SLAMè¯»å– â†’ é¢„å¤„ç† â†’ 
éª¨æ¶æå– â†’ Catmull-Romå»ºæ¨¡ â†’ å› å­å›¾ä¼˜åŒ– â†’ 
æœ€ç»ˆåœ°å›¾
```

---

### æ›´æ–°æœºåˆ¶ (`update_ctrl_pts`)

## ä¸‰ç§æ›²çº¿åœ¨è‡ªåŠ¨é©¾é©¶ä¸­çš„åº”ç”¨åœºæ™¯

### æ€»è§ˆå¯¹æ¯”

| åº”ç”¨æ¨¡å— | BÃ©zier | Catmull-Rom | B-Spline | å®é™…é‡‡ç”¨ |
|---------|--------|-------------|----------|---------|
| **è½¦é“çº¿è¡¨ç¤º** | âŒ | âœ…âœ…âœ… | âš ï¸ | **Catmull-Rom** |
| **è½¨è¿¹è§„åˆ’** | âš ï¸ | âœ…âœ… | âœ…âœ…âœ… | **B-Spline** |
| **è·¯å¾„è·Ÿè¸ª** | âŒ | âœ…âœ…âœ… | âš ï¸ | **Catmull-Rom** |
| **åœ°å›¾æ’å€¼** | âŒ | âœ…âœ… | âœ… | **éƒ½ç”¨** |
| **åŠ¨æ€é¿éšœ** | âŒ | âš ï¸ | âœ…âœ…âœ… | **B-Spline** |
| **åœè½¦è§„åˆ’** | âœ… | âœ… | âœ…âœ… | **B-Spline** |
| **UIå¯è§†åŒ–** | âœ…âœ…âœ… | âœ… | âš ï¸ | **BÃ©zier** |

### 1. è½¦é“çº¿å»ºå›¾ä¸å®šä½

#### A. è½¦é“çº¿SLAM (æœ¬é¡¹ç›®)

**é€‰æ‹©**: âœ… **Catmull-Rom**

**åŸå› **:
```python
# è½¦é“çº¿æ£€æµ‹ â†’ æ§åˆ¶ç‚¹æå– â†’ Catmull-Romæ‹Ÿåˆ
lane_points = detector.detect()  # å¯†é›†ç‚¹äº‘
ctrl_points = skeleton_extraction(lane_points, interval=3.0)  # ç¨€ç–æ§åˆ¶ç‚¹
lane_curve = CatmullRomSpline(ctrl_points)  # æ’å€¼æ›²çº¿

# ä¼˜åŠ¿:
# 1. ç²¾ç¡®é€šè¿‡è§‚æµ‹ç‚¹ â†’ ç¬¦åˆç‰©ç†çœŸå®
# 2. æ§åˆ¶ç‚¹ç›´æ¥ä¼˜åŒ– â†’ å› å­å›¾ä¼˜åŒ–ç®€å•
# 3. å±€éƒ¨æ›´æ–° â†’ æ–°è§‚æµ‹åªå½±å“å±€éƒ¨åœ°å›¾
```

**å®é™…åº”ç”¨**: 
- Apollo HD Map
- HERE HD Live Map
- TomTom RoadDNA

#### B. è½¦é“çº¿æ£€æµ‹åå¤„ç†

**é€‰æ‹©**: âœ… **Catmull-Rom** æˆ– âš ï¸ **B-Spline**

```python
# æ£€æµ‹ç»“æœå¾€å¾€æœ‰å™ªå£°
detected_points = lane_detector(image)

# æ–¹æ¡ˆ1: Catmull-Rom (å¿«é€Ÿ)
key_points = sample_keypoints(detected_points, n=10)
smooth_lane = CatmullRomSpline(key_points)

# æ–¹æ¡ˆ2: B-Spline (æ›´å¹³æ»‘,ä½†æ…¢)
control_points = fit_bspline(detected_points)
smooth_lane = BSplineCurve(control_points)
```

**è¡Œä¸šå®è·µ**:
- **ç‰¹æ–¯æ‹‰**: ä½¿ç”¨å¤šé¡¹å¼æ‹Ÿåˆ(ç±»ä¼¼Catmull-Rom)
- **Mobileye**: ä¸‰æ¬¡å¤šé¡¹å¼
- **å­¦æœ¯ç•Œ**: B-Splineç”¨äºç ”ç©¶,å®é™…äº§å“ç”¨Catmull-Rom

---

### 2. è½¨è¿¹è§„åˆ’

#### A. è¿åŠ¨è§„åˆ’ (Motion Planning)

**é€‰æ‹©**: âœ…âœ…âœ… **B-Spline**

**åŸå› **: éœ€è¦ä¼˜åŒ–åŠ åŠ é€Ÿåº¦(jerk),B-Splineçš„CÂ²è¿ç»­æ€§è‡³å…³é‡è¦

```python
# ä¼˜åŒ–ç›®æ ‡: æœ€å°åŒ–jerk
def trajectory_optimization():
    """
    minimize:  âˆ« ||dÂ³p/dtÂ³||Â² dt  (æœ€å°åŒ–åŠ åŠ é€Ÿåº¦)
    subject to:
        - åˆå§‹/ç»ˆç«¯é€Ÿåº¦ã€åŠ é€Ÿåº¦çº¦æŸ
        - ç¢°æ’é¿å…çº¦æŸ
        - åŠ¨åŠ›å­¦çº¦æŸ
    """
    # B-Splineçš„ä¼˜åŠ¿:
    # 1. CÂ²è¿ç»­ â†’ jerkæœ‰ç•Œ
    # 2. å‡¸åŒ…æ€§è´¨ â†’ ç¢°æ’æ£€æµ‹ç®€å•
    # 3. å±€éƒ¨æ§åˆ¶ â†’ å®æ—¶ä¼˜åŒ–å¯è¡Œ
    
    control_points = initial_guess()
    optimized_trajectory = bspline_optimization(control_points)
    return optimized_trajectory
```

**å®é™…ç³»ç»Ÿ**:
- **Apollo**: ä½¿ç”¨äº”æ¬¡å¤šé¡¹å¼å’ŒB-Splineç»„åˆ
- **Autoware**: EM Plannerä½¿ç”¨B-Spline
- **å­¦æœ¯**: TEB (Timed Elastic Band) ç”¨B-Spline

**ä»£ç ç¤ºä¾‹**(ä¼ªä»£ç ):
```python
# Apollo Planningæ¨¡å—
class SplineTrajectoryGenerator:
    def generate(self, waypoints, constraints):
        # 1. åˆå§‹åŒ–B-Spline
        spline = QuinticBSpline(degree=5)
        
        # 2. ä¼˜åŒ–æ§åˆ¶ç‚¹
        for iter in range(max_iter):
            cost = self.compute_cost(spline)  # jerk + collision
            gradient = self.compute_gradient(spline)
            spline.update_control_points(-lr * gradient)
        
        return spline.sample_trajectory(dt=0.1)
```

#### B. è·¯å¾„å¹³æ»‘ (Path Smoothing)

**é€‰æ‹©**: âš ï¸ **Catmull-Rom** (ç®€å•åœºæ™¯) æˆ– âœ… **B-Spline** (å¤æ‚åœºæ™¯)

```python
# åœºæ™¯1: A*ç”Ÿæˆçš„ç¦»æ•£è·¯å¾„ â†’ éœ€è¦å¹³æ»‘
raw_path = a_star_search(start, goal)  # æŠ˜çº¿è·¯å¾„

# ç®€å•å¹³æ»‘: Catmull-Rom
smooth_path = CatmullRomSpline(raw_path).sample(100)

# é«˜è´¨é‡å¹³æ»‘: B-Spline + ä¼˜åŒ–
smooth_path = optimize_bspline_path(raw_path, 
                                     minimize_curvature=True)
```

**è¡Œä¸šå®è·µ**:
- **ROS Navigation**: é»˜è®¤ä½¿ç”¨B-Splineå¹³æ»‘
- **Autoware**: Catmull-Romç”¨äºå¿«é€Ÿå¹³æ»‘
- **Apollo**: B-Splineä¼˜åŒ–

---

### 3. è·¯å¾„è·Ÿè¸ªæ§åˆ¶

#### A. MPC (æ¨¡å‹é¢„æµ‹æ§åˆ¶)

**é€‰æ‹©**: âœ… **Catmull-Rom** (å‚è€ƒè½¨è¿¹)

```python
class MPCController:
    def control(self, current_state, reference_path):
        """
        reference_path: Catmull-Romæ›²çº¿
        
        ä¼˜åŠ¿:
        1. å¿«é€ŸæŸ¥è¯¢å‚è€ƒç‚¹ â†’ O(1)å¤æ‚åº¦
        2. å‚æ•°u âˆˆ [0,1] â†’ è‡ªç„¶çš„"è¿›åº¦"è¡¨ç¤º
        3. è§£æå¯¼æ•° â†’ è®¡ç®—åˆ‡çº¿ã€æ›²ç‡æ–¹ä¾¿
        """
        # æ‰¾åˆ°æœ€è¿‘å‚è€ƒç‚¹
        u = self.find_closest_parameter(current_state, reference_path)
        
        # å‰ç»Næ­¥
        for i in range(N):
            u_future = u + i * dt * velocity
            ref_point = reference_path.evaluate(u_future)
            ref_heading = reference_path.get_tangent(u_future)
            # ... MPCä¼˜åŒ–
        
        return optimal_control
```

**å®é™…åº”ç”¨**:
- **ç‰¹æ–¯æ‹‰**: Catmull-Romç”¨äºå‚è€ƒçº¿
- **Waymo**: å†…éƒ¨ä½¿ç”¨ç±»ä¼¼æ ·æ¡æ›²çº¿

#### B. Pure Pursuit / Stanley

**é€‰æ‹©**: âœ… **Catmull-Rom** æˆ–ç®€å•**å¤šé¡¹å¼**

```python
# Pure Pursuitéœ€è¦"å‰è§†ç‚¹"
def pure_pursuit(current_pos, path, lookahead_dist):
    # Catmull-Romçš„ä¼˜åŠ¿: å¿«é€Ÿæ‰¾åˆ°å‰è§†ç‚¹
    u_current = path.find_closest_u(current_pos)
    u_lookahead = path.advance_by_distance(u_current, lookahead_dist)
    lookahead_point = path.evaluate(u_lookahead)
    
    steering_angle = compute_steering(current_pos, lookahead_point)
    return steering_angle
```

---

### 4. åœè½¦è§„åˆ’

**é€‰æ‹©**: âœ… **B-Spline** (å¹³è¡Œæ³Šè½¦) æˆ– âœ… **BÃ©zier** (ç®€å•åœºæ™¯)

#### A. å¹³è¡Œæ³Šè½¦ (Parallel Parking)

```python
# B-Splineä¼˜åŒ–æ³Šè½¦è½¨è¿¹
def plan_parking_trajectory(start_pose, goal_pose, obstacles):
    """
    çº¦æŸ:
    - è½¦è¾†è¿åŠ¨å­¦çº¦æŸ(è½¬å¼¯åŠå¾„)
    - é¿éšœçº¦æŸ
    - å¹³æ»‘æ€§çº¦æŸ(CÂ²è¿ç»­)
    """
    # åˆå§‹åŒ–B-Spline
    initial_ctrl_pts = generate_initial_path(start_pose, goal_pose)
    spline = CubicBSpline(initial_ctrl_pts)
    
    # ä¼˜åŒ–
    optimized_spline = optimize(
        spline,
        constraints=[kinematic, collision_free, smooth],
        objective=minimize_time
    )
    
    return optimized_spline.sample()
```

**å®é™…ç³»ç»Ÿ**:
- **Bosch**: B-Splineä¼˜åŒ–
- **å­¦æœ¯**: Hybrid A* + B-Splineåå¤„ç†

#### B. å‚ç›´æ³Šè½¦ (Perpendicular Parking)

```python
# ç®€å•åœºæ™¯å¯ç”¨BÃ©zier
def simple_parking_bezier(start, goal):
    """
    å‚ç›´æ³Šè½¦é€šå¸¸åªéœ€è¦ç®€å•çš„Så½¢æ›²çº¿
    """
    # 4ä¸ªæ§åˆ¶ç‚¹å®šä¹‰ä¸‰æ¬¡BÃ©zier
    P0 = start
    P3 = goal
    P1 = start + offset_forward
    P2 = goal - offset_backward
    
    bezier = BezierCurve([P0, P1, P2, P3])
    return bezier.sample(50)
```

---

### 5. åŠ¨æ€é¿éšœ

**é€‰æ‹©**: âœ…âœ…âœ… **B-Spline**

```python
# å®æ—¶é¿éšœéœ€è¦å¿«é€Ÿå˜å½¢è½¨è¿¹
class DynamicObstacleAvoidance:
    def replan(self, original_trajectory, new_obstacle):
        """
        B-Splineçš„å±€éƒ¨æ€§è‡³å…³é‡è¦:
        - åªéœ€è°ƒæ•´å‡ ä¸ªæ§åˆ¶ç‚¹
        - ä¸å½±å“è¿œå¤„çš„è½¨è¿¹
        """
        # æ‰¾åˆ°å—å½±å“çš„æ§åˆ¶ç‚¹
        affected_indices = self.find_affected_control_points(
            original_trajectory, new_obstacle)
        
        # åªä¼˜åŒ–è¿™äº›æ§åˆ¶ç‚¹
        for idx in affected_indices:
            new_pos = self.compute_avoidance_position(idx, new_obstacle)
            original_trajectory.update_control_point(idx, new_pos)
        
        return original_trajectory  # å®æ—¶æ›´æ–°!
```

**å®é™…åº”ç”¨**:
- **TEB Local Planner** (ROS): ä½¿ç”¨B-Splineå˜ç§
- **Elastic Band**: åŠ¨æ€è°ƒæ•´B-Splineæ§åˆ¶ç‚¹

---

### 6. é«˜ç²¾åœ°å›¾åˆ¶ä½œ

#### A. é“è·¯ä¸­å¿ƒçº¿æ‹Ÿåˆ

**é€‰æ‹©**: âœ… **Catmull-Rom** (åœ¨çº¿) + âœ… **B-Spline** (ç¦»çº¿ä¼˜åŒ–)

```python
# åœ¨çº¿å»ºå›¾: Catmull-Rom
def online_mapping(gps_traces):
    key_points = extract_keypoints(gps_traces)
    centerline = CatmullRomSpline(key_points)
    return centerline

# ç¦»çº¿ä¼˜åŒ–: B-Spline
def offline_optimization(raw_centerlines):
    # å…¨å±€ä¼˜åŒ–,è€ƒè™‘æ‰€æœ‰çº¦æŸ
    optimized = global_bspline_fitting(
        raw_centerlines,
        smoothness_weight=1.0,
        data_fidelity_weight=0.5
    )
    return optimized
```

**è¡Œä¸šå®è·µ**:
- **HERE**: å¤šçº§LOD,ä½ç²¾åº¦ç”¨Catmull-Rom,é«˜ç²¾åº¦ç”¨B-Spline
- **TomTom**: ç±»ä¼¼æ–¹æ¡ˆ

#### B. è½¦é“çº¿è¿æ¥ä¸æ’å€¼

**é€‰æ‹©**: âœ… **Catmull-Rom**

```python
# è¿æ¥ä¸åŒè·¯æ®µçš„è½¦é“çº¿
def connect_lane_segments(segment1_end, segment2_start):
    """
    Catmull-Romè‡ªåŠ¨å¹³æ»‘è¿æ¥
    """
    # å–ä¸¤æ®µå„ä¸¤ä¸ªæ§åˆ¶ç‚¹
    ctrl_pts = [
        segment1_end[-2],
        segment1_end[-1],
        segment2_start[0],
        segment2_start[1]
    ]
    
    # ç”Ÿæˆè¿æ¥æ›²çº¿
    connection = CatmullRomSpline(ctrl_pts)
    return connection
```

---

### 7. UIå¯è§†åŒ–

**é€‰æ‹©**: âœ…âœ…âœ… **BÃ©zier**

```python
# ä»ªè¡¨ç›˜æ˜¾ç¤ºé¢„æµ‹è½¨è¿¹
def visualize_predicted_path(path_points):
    """
    BÃ©zierçš„ä¼˜åŠ¿:
    1. SVG/CanvasåŸç”Ÿæ”¯æŒ
    2. å°‘é‡æ§åˆ¶ç‚¹,ä¼ è¾“é«˜æ•ˆ
    3. è§†è§‰æ•ˆæœæµç•…
    """
    # æŠ½å–4ä¸ªå…³é”®ç‚¹
    key_points = sample_uniform(path_points, n=4)
    
    # ç”ŸæˆSVGè·¯å¾„
    svg_path = f"M {key_points[0]} C {key_points[1]}, " \
               f"{key_points[2]}, {key_points[3]}"
    
    return svg_path
```

**å®é™…åº”ç”¨**:
- **ç‰¹æ–¯æ‹‰å¯è§†åŒ–**: BÃ©zieræ›²çº¿
- **è½¦è½½HMI**: å¤§é‡ä½¿ç”¨BÃ©zier
- **Apollo Dreamview**: BÃ©zierç”¨äºUI,B-Splineç”¨äºå®é™…è§„åˆ’

---

### æ€»ç»“: é€‰æ‹©æŒ‡å—

| éœ€æ±‚ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|---------|------|
| å¿…é¡»é€šè¿‡æŒ‡å®šç‚¹ | **Catmull-Rom** | æ’å€¼æ€§è´¨ |
| æœ€å¤§å¹³æ»‘æ€§ | **B-Spline** | CÂ²è¿ç»­ |
| å®æ—¶æ€§è¦æ±‚é«˜ | **Catmull-Rom** | O(1)è®¡ç®— |
| å…¨å±€ä¼˜åŒ– | **B-Spline** | æ•°å€¼ç¨³å®š |
| å±€éƒ¨ç¼–è¾‘ | **Catmull-Rom/B-Spline** | å±€éƒ¨æ€§ |
| UIç»˜å›¾ | **BÃ©zier** | åŸç”Ÿæ”¯æŒ |
| ç®€å•åœºæ™¯ | **BÃ©zier** | ç›´è§‚ç®€å• |
| SLAM/å»ºå›¾ | **Catmull-Rom** | æ’å€¼+å±€éƒ¨æ€§ |
| è¿åŠ¨è§„åˆ’ | **B-Spline** | å¹³æ»‘æ€§ |

**å®è·µå»ºè®®**:
1. **ä¸è¦æ­»æ¿**: æ··åˆä½¿ç”¨å¤šç§æ–¹æ³•
   - å»ºå›¾ç”¨Catmull-Rom
   - è§„åˆ’ç”¨B-Spline
   - å¯è§†åŒ–ç”¨BÃ©zier

2. **æ ¹æ®çº¦æŸé€‰æ‹©**:
   - ç¡¬çº¦æŸ(å¿…é¡»é€šè¿‡ç‚¹) â†’ Catmull-Rom
   - è½¯çº¦æŸ(å°½é‡å¹³æ»‘) â†’ B-Spline

3. **æ€§èƒ½vsè´¨é‡æƒè¡¡**:
   - å®æ—¶ç³»ç»Ÿ â†’ Catmull-Rom
   - ç¦»çº¿ä¼˜åŒ– â†’ B-Spline

---

## ä»£ç ç¤ºä¾‹

### å­¦æœ¯è®ºæ–‡
1. BÃ©zier, P. (1962). "Numerical Control: Mathematics and Applications"
2. Catmull, E. & Rom, R. (1974). "A Class of Local Interpolating Splines"
3. de Boor, C. (1972). "On Calculating with B-Splines"

### åœ¨çº¿èµ„æº
- [Primer on BÃ©zier Curves](https://pomax.github.io/bezierinfo/)
- [Catmull-Rom Splines in Computer Graphics](https://www.cs.cmu.edu/~462/projects/assn2/assn2/catmullRom.pdf)
- [B-Spline Tutorial](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/)

### ä»£ç åº“
- MonoLaneMapping: `misc/curve/catmull_rom.py`, `misc/curve/bspline.py`
- Geomdl: https://github.com/orbingol/NURBS-Python
- SciPy: `scipy.interpolate.CubicSpline`, `scipy.interpolate.splprep`

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-12-15  
**æœ€åæ›´æ–°**: 2025-12-15  
**ä½œè€…**: MonoLaneMappingé¡¹ç›®ç»„

**æ›´æ–°æ—¥å¿—**:
- v2.0: æ–°å¢"æ§åˆ¶ç‚¹é€‰å–ç®—æ³•"å’Œ"è‡ªåŠ¨é©¾é©¶åº”ç”¨åœºæ™¯"ç« èŠ‚
- v1.0: åˆå§‹ç‰ˆæœ¬,åŒ…å«ä¸‰ç§æ›²çº¿çš„æ•°å­¦åŸç†å’Œå®ç°å¯¹æ¯”  
**ä½œè€…**: MonoLaneMappingé¡¹ç›®ç»„
